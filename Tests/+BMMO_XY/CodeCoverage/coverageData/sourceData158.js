var sourceData158 = {"FileContents":["function [mlo, stat, data_accepted] = bmmo_outlier_removal(mli, options)\r","% function [mlo, stat, data_accepted] = bmmo_outlier_removal(mli, options)\r","%\r","% This function is the outlier removal sub-model for bmmo_nxe_drift_control_model\r","% It detects outliers from the input data and set their dx, dy to\r","% NaN\r","%\r","% Input:\r","%   mli: input ml structure, field reconstruction has been completed\r","%   options: BMMO/BL3 default options structure\r","%\r","% Output:\r","%   mlo: output ml structure where outliers have been removed\r","%   stat: structure containing details of each outlier (location etc) per\r","%       wafer, per layer,  as defined in ovl_remove_outliers\r","%   data_accepted: True if outlier density is lower than threshold defined in\r","%       options.outlier_max_fraction\r","%\r","% For details of the model and definitions of in/out interfaces, refer to\r","% D000810611 EDS BMMO NXE drift control model\r","\r","% Declare constants\r","outlier_type.INVALID = 1;\r","outlier_type.W2W = 2;\r","outlier_type.MODEL = 3;\r","\r","mlo = mli;\r","\r","if options.chuck_usage.chuck_id_used(1) == 2\r","    mli(2) = mli;\r","end\r","[FPS, C] = bmmo_construct_FPS(mli, options, 'OR');\r","data_accepted = true;\r"," \r","if mlo.nlayer == 1\r","    mlo_s = mlo;\r","elseif mlo.nlayer == 2 % ( s2f )\r","    mlo_s = ovl_sub(ovl_get_layers(mlo,2),ovl_get_layers(mlo,1)); \r","else\r","    error('Data must have single layer or two layers.');\r","end\r","\r","if data_accepted\r","    % 1st step, limit overlay larger than options.outlier_max_ovl\r","    for iwafer = 1:mlo_s.nwafer\r","        this_waf = ovl_get_wafers(mlo_s,iwafer);\r","        [~, ~, ~, ~, dx, dy] = ovl_concat_wafer_results(this_waf);\r","         \r","        idx = find(abs(dx) > options.outlier_max_ovl);\r","        idy = find(abs(dy) > options.outlier_max_ovl);\r","        id_over_limit = unique([idx;idy]);\r","        mlo_s.layer.wr(iwafer).dx(id_over_limit) = NaN;\r","        mlo_s.layer.wr(iwafer).dy(id_over_limit) = NaN;\r","        \r","        stat_this_wafer(iwafer).x   = this_waf.wd.xw(id_over_limit);\r","        stat_this_wafer(iwafer).y   = this_waf.wd.yw(id_over_limit);\r","        stat_this_wafer(iwafer).idx = id_over_limit;\r","        stat_this_wafer(iwafer).r   = sqrt(this_waf.wd.xw(id_over_limit).^2 + this_waf.wd.xw(id_over_limit).^2);\r","        stat_this_wafer(iwafer).dr  = sqrt(this_waf.layer.wr.dx(id_over_limit).^2 + this_waf.layer.wr.dy(id_over_limit).^2);\r","        stat_this_wafer(iwafer).n   = numel(id_over_limit); \r","        stat_this_wafer(iwafer).type = outlier_type.INVALID * ones(size(id_over_limit));\r","    end\r","    % 2nd step, w2w outlier removal\r","    for chuck_id = options.chuck_usage.chuck_id_used\r","        this_wafer = find(options.chuck_usage.chuck_id == chuck_id);\r","        ml_ch = ovl_get_wafers(mlo_s, this_wafer);\r","        test_constants.coverage_factor = options.outlier_coverage_factor;\r","        test_constants.remove_large = 0;\r","        \r","        [ml_after,  outliers_data] = ovl_w2w_outliers(ml_ch,'coverage_factor',options.outlier_coverage_factor,...\r","            'neighborhood_radius',options.outlier_check_radius);\r","        \r","        for iwafer = this_wafer\r","            ol_wafer_index = find(this_wafer == iwafer);\r","            if ~isempty(outliers_data.lay.outliers_data)\r","                \r","                index = find(vertcat(outliers_data.lay.outliers_data(:).iwafer)==ol_wafer_index);\r","                \r","                if(index)\r","                    ol_data_iwaf = outliers_data.lay.outliers_data(index);\r","                    \r","                    stat_this_wafer1(iwafer).x = [ol_data_iwaf.xw]';\r","                    stat_this_wafer1(iwafer).y = [ol_data_iwaf.yw]';\r","                    stat_this_wafer1(iwafer).idx = ([ol_data_iwaf.ifield]'-1)*mlo_s.nmark + [ol_data_iwaf.imark]';\r","                    stat_this_wafer1(iwafer).r = sqrt([ol_data_iwaf.xw].^2 + [ol_data_iwaf.yw].^2)';\r","                    stat_this_wafer1(iwafer).dr = sqrt([ol_data_iwaf.dx].^2 + [ol_data_iwaf.dy].^2)';\r","                    stat_this_wafer1(iwafer).n = numel(ol_data_iwaf);\r","                    stat_this_wafer1(iwafer).type = outlier_type.W2W * ones(numel(ol_data_iwaf), 1);\r","                    stat_this_wafer(iwafer) = sub_combine_outlier_stat(stat_this_wafer(iwafer), stat_this_wafer1(iwafer));\r","                end\r","            end\r","            mlo_s.layer.wr(iwafer) = ml_after.layer.wr(ol_wafer_index);\r","        end\r","    end \r","    \r","    % 3rd step, run combined model then detect outlier from the residue\r","    for iwafer = 1:mlo_s.nwafer\r","        options_copy                           = options;\r","        options_copy.chuck_usage.chuck_id      = options.chuck_usage.chuck_id(iwafer);\r","        options_copy.chuck_usage.chuck_id_used = options_copy.chuck_usage.chuck_id;\r","        options_copy.chuck_usage.nr_chuck_used = 1;\r","        this_waf = ovl_get_wafers(mlo_s,iwafer);\r","        \r","        outlier_found = true;\r","       \r","       while outlier_found\r","            outlier_input(options_copy.chuck_usage.chuck_id) = this_waf;\r","            [~, ~, res] = bmmo_fit_fingerprints(outlier_input, FPS, options_copy, C);\r","            res = res(options_copy.chuck_usage.chuck_id_used);\r","            [~, ~, ~, ~, stats_outl2] = ovl_remove_outliers(res, 'nxe', options_copy.outlier_coverage_factor);\r","            stats_outl2.layer.wafer.type = outlier_type.MODEL * ones(stats_outl2.layer.wafer.n, 1);\r","            \r","            stat_this_wafer(iwafer) = sub_combine_outlier_stat(stat_this_wafer(iwafer), stats_outl2.layer.wafer);\r","            idx_out = stats_outl2.layer.wafer.idx;\r","            this_waf.layer.wr.dx(idx_out) = NaN;\r","            this_waf.layer.wr.dy(idx_out) = NaN;\r","            if isempty(idx_out)\r","                outlier_found = false;\r","            end\r","        end\r","        mlo_s.layer.wr(iwafer).dx  = this_waf.layer.wr.dx;\r","        mlo_s.layer.wr(iwafer).dy  = this_waf.layer.wr.dy;\r","        stat1.wafer(iwafer) = stat_this_wafer(iwafer);\r","    end\r","    for ilayer = 1:mlo.nlayer\r","        for iwafer = 1:mlo.nwafer\r","            mlo.layer(ilayer).wr(iwafer).dx = mlo_s.layer.wr(iwafer).dx;\r","            mlo.layer(ilayer).wr(iwafer).dy = mlo_s.layer.wr(iwafer).dy;\r","            stat.layer(ilayer).wafer(iwafer) = stat1.wafer(iwafer);\r","        end\r","    end    \r","end\r","\r","\r","function out = sub_combine_outlier_stat(in1,in2)\r","out.x   = [in1.x; in2.x];\r","out.y   = [in1.y; in2.y];\r","out.idx = [in1.idx; in2.idx];\r","out.r   = [in1.r; in2.r];\r","out.dr  = [in1.dr; in2.dr];\r","out.n   = in1.n + in2.n;\r","out.type = [in1.type; in2.type];\r",""],"CoverageData":{"CoveredLineNumbers":[23,24,25,27,29,30,32,33,35,36,43,45,46,47,49,50,51,52,53,55,56,57,58,59,60,61,64,65,66,67,68,70,71,73,74,75,77,79,80,82,83,84,85,86,87,88,89,92,97,98,99,100,101,102,104,106,107,108,109,110,111,113,114,115,116,117,118,121,122,123,125,126,127,128,129,136,137,138,139,140,141,142],"UnhitLineNumbers":[37,38,39,40],"HitCount":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,122,122,122,0,122,0,122,12,0,122,122,0,122,122,0,0,0,0,0,0,122,0,122,632,632,0,632,632,632,632,632,0,632,632,632,632,632,632,632,0,0,122,238,238,238,238,0,238,238,0,238,632,632,0,253,0,253,176,0,176,176,176,176,176,176,176,176,0,0,632,0,0,0,0,122,632,632,632,632,632,0,632,0,632,799,799,799,799,799,0,799,799,799,799,799,632,0,0,632,632,632,0,122,122,632,632,632,0,0,0,0,0,0,975,975,975,975,975,975,975,0]}}