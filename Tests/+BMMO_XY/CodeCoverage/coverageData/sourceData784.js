var sourceData784 = {"FileContents":["function verifyMlWithinTol(obj, actual, expected, varargin)\r","% verifyMlWithinTol(obj, actual, expected, varargin)\r","%\r","% This function verifies whether the ml provided as \"actual\" is equal to \r","% the ml provided as \"expected\". \r","% When comparing overlapping marks only:\r","% \"expected\" is to be the superset of the subset \"actual\".\r","%\r","% The optional input arguments are as follows:\r","%\r","%   <label>, <value>    [type]                  default value\r","%\r","% - 'type'              [char array]            'abs'\r","% - 'tol'               [double (real)]         '5e-13'\r","% - 'perMark'           [char array]            false\r","\r","\r","import matlab.unittest.constraints.IsTrue\r","\r","in = getComparisonSettings(varargin);\r","\r","fieldNames = {'nmark', 'nfield', 'nwafer', 'nlayer', 'wd', 'layer'};\r","\r","for nameIndex = 1 : length(fieldNames)\r","    fieldName = fieldNames{nameIndex};\r","    obj.verifyThat(isfield(actual, fieldName), IsTrue);\r","    obj.verifyThat(isfield(expected, fieldName), IsTrue);\r","end\r","\r","% Restructure \"expected\" to set marks of subset \"actual\"\r","if in.perMark\r","    expected = subSortMarks(obj, actual, expected);\r","end\r","\r","obj.verifyEqual(actual.nmark, expected.nmark);\r","obj.verifyEqual(actual.nfield, expected.nfield);\r","obj.verifyEqual(actual.nwafer, expected.nwafer);\r","obj.verifyEqual(actual.nlayer, expected.nlayer);\r","\r","obj.verifyWithinTol(actual.wd, expected.wd, 'tol', obj.mlWdTol, 'type', 'abs');\r","obj.verifyWithinTol(actual.layer, expected.layer, 'tol', in.tol, 'type', in.type);\r","end\r","\r","\r","% \"expected\" is reduced and sorted to its subset \"actual\"\r","function expected = subSortMarks(obj, actual, expected)\r","    \r","    % Find rounded mark positions\r","    roundedActualMarkPostitions   = round([actual.wd.xw, actual.wd.yw], 6);\r","    roundedExpectedMarkPostitions = round([expected.wd.xw, expected.wd.yw], 6);\r","\r","    % Check if actual is non-empty\r","    obj.assertTrue(~isempty(roundedActualMarkPostitions), 'Actual ml wafer definition is empty');\r","\r","    % Create mapping for actual mark positions to match those of expected\r","    [check, mapping] = ismember(roundedActualMarkPostitions, roundedExpectedMarkPostitions, 'rows');\r","    \r","    % Check if actual is in fact a subset of expected\r","    obj.assertTrue(all(check), 'Actual ml is not a subset of expected ml');\r","\r","    % Obtain position and overlay fieldnames for simple access\r","    positionFields = fieldnames(expected.wd);\r","    overlayFields  = fieldnames(expected.layer.wr);\r","\r","    % Apply mapping to position\r","    for posFieldIndex = 1:length(positionFields)\r","        expectedPos = expected.wd.(positionFields{posFieldIndex});\r","        expected.wd.(positionFields{posFieldIndex}) = expectedPos(mapping, :);\r","    end\r","    \r","    % Apply mapping to overlay for each wafer\r","    for ovlFieldIndex = 1:length(overlayFields)\r","        for waferIndex = 1:expected.nwafer\r","            expectedOvl = expected.layer.wr(waferIndex).(overlayFields{ovlFieldIndex});\r","            expected.layer.wr(waferIndex).(overlayFields{ovlFieldIndex}) = expectedOvl(mapping, :);\r","        end\r","    end\r","\r","    expected.nfield = actual.nfield;\r","    expected.nmark  = actual.nmark;\r","end"],"CoverageData":{"CoveredLineNumbers":[],"UnhitLineNumbers":[20,22,24,25,26,27,31,32,35,36,37,38,40,41,49,50,53,56,59,62,63,66,67,68,72,73,74,75,79,80],"HitCount":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}}