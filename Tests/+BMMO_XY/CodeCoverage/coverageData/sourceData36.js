var sourceData36 = {"FileContents":["function [mlo, params] = bmmo_apply_KA(ml_KA, ml_layout, varargin)\r","% function [mlo, params] = bmmo_apply_KA(ml_KA, ml_layout, varargin)\r","%\r","% Created from gxy_mc_apply_KA where the type hardcoded to 'expose'. The\r","% function does 6par per field actuation of the given KA grid .\r","%\r","% Inputs:\r","%  ml_KA        : ml structure containing KA map to be applied\r","%  ml_layout  : ml structure containing layout to which KA map should\r","%                 be applied (dx & dy values are not used)\r","% Options:\r","%  img_size     : 2-element vector describing the size of the exposed field\r","%                 (not relevant if type is 'readout' or 'alignment')\r","%                 if not specified, it will be guessed based on 'type'\r","%\r","% Output:\r","%  mlo          : ml structure containing the correction applied based on\r","%                 supplied map. mlo contains as many (identical) wafers\r","%                 as present in layout_tlg, but applied to only one layer.\r","% params          parmeters per mark/field determined from ml_KA and\r","%                 applied to mlo\r","\r","% options\r","options.img_size               = 'guess';\r","options.params                 = 'guess';\r","[options, args]                = getopts_r12(options, varargin{:});\r","\r","% guessing\r","if isstr(options.img_size) & strcmp(options.img_size, 'guess')\r","    options.img_size       = [26 33] * 1e-3;\r","end\r","if isstr(options.params) & strcmp(options.params, 'guess')\r","    options.params         = {'tx', 'ty', 'ms', 'ma', 'rs', 'ra'}; % but will fallback if too little data is available (wafer edge)\r","end\r","% more validation\r","% validateattributes(options.img_size, {'numeric'}, {'size', [1 2]});\r","if ~isnumeric(options.img_size)\r","    error('options.img_size should be numeric');\r","elseif ~isequal(size(options.img_size),[1 2])\r","    error('options.img_size size should be [1 2]');\r","end\r","\r","% initialize outputs\r","mlo                            = ovl_metro_get_subset(ml_layout, 1, 1);\r","mlo.layer.wr.dx                = mlo.layer.wr.dx * 0;\r","mlo.layer.wr.dy                = mlo.layer.wr.dy * 0;\r","mlo.tlgname                    = ['KA actuation - expose'];\r","\r","% precompute unique values to avoid performance hit in point loop\r","ml_KA.xu                       = unique(ml_KA.wd.xw);\r","ml_KA.yu                       = unique(ml_KA.wd.yw);\r","\r","% calculate the parameters per mark/field\r","for ifield = 1:mlo.nfield\r","    index = mlo.nmark * (ifield-1);\r","    params.field(ifield) = sub_determine_2dc_correction(ml_KA, mlo.wd.xc(index + 1), mlo.wd.yc(index + 1), options.img_size, options.params);\r","end\r","\r","% apply the parameters to mlo\r","params = bmmo_add_field_positions_to_parlist(params, mlo);\r","mlo = ovl_model(mlo, 'apply', params);\r","\r","\r","%% ==== SUB FUNCTIONS =====================================================\r","\r","function par = sub_determine_2dc_correction(ka_tlg, x, y, img_size, fitparams)\r","\r","border_size = 5e-3;\r","grid_dist   = 5e-3;\r","\r","par.tx = 0;\r","par.ty = 0;\r","par.ms = 0;\r","par.ma = 0;\r","par.rs = 0;\r","par.ra = 0;\r","\r","xu = ka_tlg.xu; % precomputed\r","yu = ka_tlg.yu;\r","xyf = [ka_tlg.wd.xw ka_tlg.wd.yw];\r","\r","% Define area of interest\r","xmin = x - img_size(1)/2 - border_size;\r","xmax = x + img_size(1)/2 + border_size;\r","ymin = y - img_size(2)/2 - border_size;\r","ymax = y + img_size(2)/2 + border_size;\r","\r","xi = find(xu<=xmax & xu>=xmin);\r","yi = find(yu<=ymax & yu>=ymin);\r","\r","if length(xi)==0 | length(yi)==0, return; end\r","xyi = find(xyf(:,1) >= xu(xi(1)) & xyf(:,1) <= xu(xi(end)) & ...\r","    xyf(:,2) >= yu(yi(1)) & xyf(:,2) <= yu(yi(end)));\r","\r","ka_dx = ka_tlg.layer.wr.dx(xyi);\r","ka_dy = ka_tlg.layer.wr.dy(xyi);\r","ka_x  = ka_tlg.wd.xw(xyi);\r","ka_y  = ka_tlg.wd.yw(xyi);\r","idx_ka_nan = find(isnan(ka_dx)); % should not happen since 2DC 3300 always extrapolates and fills holes...\r","\r","rel_pos     = xyf(xyi,:)-repmat([x y],size(xyi));\r","abs_rel_pos = abs(rel_pos);\r","\r","ind_inner_x = find(abs_rel_pos(:,1) - repmat(img_size(1)/2, size(rel_pos, 1), 1) <= 0);\r","ind_inner_y = find(abs_rel_pos(:,2) - repmat(img_size(2)/2, size(rel_pos, 1), 1) <= 0);\r","ind_outer_x = find(abs_rel_pos(:,1) - repmat(img_size(1)/2, size(rel_pos, 1), 1) > 0);\r","ind_outer_y = find(abs_rel_pos(:,2) - repmat(img_size(2)/2, size(rel_pos, 1), 1) > 0);\r","\r","dist_from_img_border(ind_outer_x,1) = abs_rel_pos(ind_outer_x,1) - img_size(1)/2;\r","dist_from_img_border(ind_outer_y,2) = abs_rel_pos(ind_outer_y,2) - img_size(2)/2;\r","dist_from_img_border(ind_inner_x,1) = 0;\r","dist_from_img_border(ind_inner_y,2) = 0;\r","\r","% apply weighting factors\r","weight = prod((border_size-dist_from_img_border)/border_size, 2);\r","\r","%Ex = max(xu(xi)) - min(xu(xi));\r","%Ey = max(yu(yi)) - min(yu(yi));\r","\r","real = find(~isnan(ka_tlg.layer.wr.dx(xyi)) & ~isnan(ka_tlg.layer.wr.dy(xyi)));\r","\r","% bugfix: calculate Ex and Ey based on valid points only\r","% (ovl_model_2dc_correction did this wrongly)\r","Ex = max(ka_x(real)) - min(ka_x(real));\r","Ey = max(ka_y(real)) - min(ka_y(real));\r","\r","if length(real) ~= 0\r","    N = length(real);\r","    w = weight(real);\r","    \r","    % check for parameter fallback\r","    tol = 1e-8;\r","    fallback = 0;\r","    if (Ex < 2*grid_dist-tol) & (Ey < 2*grid_dist-tol)\r","        fallback = 2;\r","        fitparams = {'tx', 'ty'}; % translation only\r","    end\r","    if (Ex < 2*grid_dist-tol) | (Ey < 2*grid_dist-tol) | (length(real) < 3)\r","        % fallback to 4par (\"sym only\")\r","        if numel(fitparams) > 2\r","            fallback = 4;\r","            fitparams = {'tx', 'ty', 'ms', 'rs'};\r","        end\r","    end\r","    \r","    % construct design matrix\r","    % TODO use some core OVL linear modeling engine, like ovl_metro_model\r","    xf = rel_pos(real, 1);\r","    yf = rel_pos(real, 2);\r","    \r","    z = zeros(N,1);\r","    o = ones(N,1);\r","    \r","    %     Tx      Ty      Ms       Ma         Rs        Ra\r","    A = [[o; z] [z; o] [xf; yf] [xf; -yf] [-yf; xf] [-yf; -xf]];\r","    if ~ismember('ra', fitparams)\r","        A(:,6) = 0;\r","    end\r","    if ~ismember('ma', fitparams)\r","        A(:,4) = 0;\r","    end\r","    if ~ismember('rs', fitparams)\r","        A(:,5) = 0;\r","    end\r","    if ~ismember('ms', fitparams)\r","        A(:,3) = 0;\r","    end\r","    \r","    % Apply weight factors\r","    A = A .* repmat(w, 2, 6);\r","    \r","    dx = ka_tlg.layer.wr.dx(xyi(real)).* w;\r","    dy = ka_tlg.layer.wr.dy(xyi(real)).* w;\r","    \r","    % solve\r","    parvec = pinv(A) * [dx; dy];\r","    \r","    par.tx    = parvec(1);\r","    par.ty    = parvec(2);\r","    par.ms    = parvec(3);\r","    par.ma    = parvec(4);\r","    par.rs    = parvec(5);\r","    par.ra    = parvec(6);\r","end\r",""],"CoverageData":{"CoveredLineNumbers":[24,25,26,29,30,32,33,37,39,44,45,46,47,50,51,54,55,56,60,61,68,69,71,72,73,74,75,76,78,79,80,83,84,85,86,88,89,91,92,93,95,96,97,98,99,101,102,104,105,106,107,109,110,111,112,115,120,124,125,127,128,129,132,133,134,135,136,138,140,141,142,148,149,151,152,155,156,157,159,160,162,163,165,166,170,172,173,176,178,179,180,181,182,183],"UnhitLineNumbers":[38,40],"HitCount":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2427,2427,2427,0,0,2427,2427,0,2427,2427,0,0,0,2427,0,2427,0,0,0,0,2427,2427,2427,2427,0,0,2427,2427,0,0,2427,316623,316623,0,0,0,2427,2427,0,0,0,0,0,0,316623,316623,0,316623,316623,316623,316623,316623,316623,0,316623,316623,316623,0,0,316623,316623,316623,316623,0,316623,316623,0,316623,316623,316623,0,316623,316623,316623,316623,316623,0,316623,316623,0,316623,316623,316623,316623,0,316623,316623,316623,316623,0,0,316623,0,0,0,0,316623,0,0,0,316623,316623,0,316623,316623,316623,0,0,316623,316623,316623,8,8,0,316623,0,2193,2185,2185,0,0,0,0,0,316623,316623,0,316623,316623,0,0,316623,316623,2193,0,316623,2193,0,316623,8,0,316623,8,0,0,0,316623,0,316623,316623,0,0,316623,0,316623,316623,316623,316623,316623,316623,0,0]}}