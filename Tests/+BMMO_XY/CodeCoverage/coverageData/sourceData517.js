var sourceData517 = {"FileContents":["function sbc2 = bmmo_kt_process_sbc_correction(sbc2, corr_set, index)\r","%  function sbc2 = bmmo_kt_process_sbc_correction(sbc2, corr_set, index)\r","%\r","%  Process a single correction from an ADELsbcOverlayDriftControlNxe or\r","%   ADELsbcOverlayDriftControlNxeRep\r","%\r","% Input: sbc2: input sbc2 correction set\r","%        corr_set: either CorrectionSets(index).elt.Parameters (from SBCnxe)\r","%             or AppliedCorrectionList(index).elt.Corrections (from SBCnxerep)\r","%        index: index of correction set in XML file\r","%\r","% Output: sbc2: input sbc2 with correction added\r","%\r","%\r","% 20160503 SBPR Refactored from bmmo_kt_process_SBC2\r","% 20190322 SELR Preparation code for SUSD SBC (according to SIA-0)\r","% 20190801 SELR Updated for IFO in SBC2\r","\r","\r","\r","\r","par_names = {'SdmDistortionMap', 'MiMirrorOffsetMapMeasure', ...\r","    'MiMirrorOffsetMapExpose', 'KaOffsetMapExpose', ...\r","    'BlueAlignmentOffset', 'WaferHeatingOffset', 'IntraFieldOffset','KaOffsetMapMeasure'};\r","struct_fields = {'ffp', 'wsm', 'wse', 'grid_2de', 'BAO', 'IR2EUV', 'SUSD','grid_2dc'};\r","\r","processing_functions = {@sub_parse_SDM, @sub_parse_MI, @sub_parse_MI, ...\r","    @sub_parse_KA, @sub_parse_BAO, @sub_parse_WH, @sub_parse_SUSD, @sub_parse_KA};\r","\r","for j = 1:length(par_names)\r","    if isfield(corr_set, par_names{j})\r","        correction = feval(processing_functions{j}, corr_set.(par_names{j}));\r","        \r","        switch j\r","            case 2\r","                sbc2.MI.(struct_fields{j})(index) = correction;\r","            case 3\r","                sbc2.MI.(struct_fields{j})(index) = correction;\r","            case 4\r","                sbc2.KA.(struct_fields{j})(index) = correction;\r","            case 8\r","                sbc2.KA.(struct_fields{j})(index) = correction;\r","            otherwise\r","                sbc2.(struct_fields{j})(index) = correction;\r","        end\r","    end\r","end\r","\r","\r","% sub_parse_SDM\r","function grid = sub_parse_SDM(xml)\r","\r","% dummy field will provide the x and y\r","dummy_field = ovl_get_fields(ovl_create_dummy('13x19', 'nlayer', 1, 'nwafer', 1), 1);\r","\r","% From ADEL definition:\r","% List of offsets in X, Y, representing the XY map. The position in the list of\r","% map element (X,Y) can be found at position X + Y * (StepsX + 1) where StepsX\r","% is defined in the header of the map\r","g = [xml.Offsets.elt];\r","xg = str2double({g.X});\r","yg = str2double({g.Y});\r","xg = xg' * 1e-9;\r","yg = yg' * 1e-9;\r","\r","% dummy_field has x in rows and y in cols: want to simulate this\r","% from definition: r,c = r + c * 13\r","% then the order of xg (before meander added) is:\r","% 0 = (0,0)\r","% 1 = (1,0)\r","% ...\r","%12 = (12,0),\r","%13 = (0,1)\r","%14 = (1,1) (etc)\r","% so xg has (meander excepted) the same order as dummy_field.wd.xf\r","\r","% With the same meander as dummy_field.wd.xf, it should have this\r","% order:\r","% 0 = (0,0)\r","% 1 = (1,0)\r","% ...\r","%12 = (12,0),\r","%13 = (12,1)\r","%14 = (11,1) (etc)\r","\r","% reshape to a 13x19 matrix\r","% Now all columns contain ascending x-values in the same order\r","xg = reshape(xg, 13, 19);\r","yg = reshape(yg, 13, 19);\r","\r","% To match the meander of the data in dummy_field, every second column\r","% should be flipped top to bottom\r","xg(:, 2:2:end) = flipud(xg(:,2:2:end));\r","xg = xg(:);\r","\r","yg(:, 2:2:end)  = flipud(yg(:,2:2:end));\r","yg = yg(:);\r","\r","grid.x = dummy_field.wd.xf;\r","grid.y = dummy_field.wd.yf;\r","grid.dx = xg;\r","grid.dy = yg;\r","\r","\r","% sub_parse_MI (parses one set of mirror maps for one chuck, i.e. either expose or mirror side, either chuck 1 or chuck 2)\r","function mirr = sub_parse_MI(xml)\r","mirr.x_mirr = sub_parse_mirr(xml.YTXMirrorMap, 'y', 'dx');\r","mirr.y_mirr = sub_parse_mirr(xml.XTYMirrorMap, 'x', 'dy');\r","\r","\r","% sub_parse_KA\r","function grid = sub_parse_KA(xml)\r","grid = sub_parse_grid_new(xml);\r","\r","\r","\r","% sub_parse_BAO\r","function BAO = sub_parse_BAO(xml)\r","\r","NM = 1e-9;\r","UM = 1e-6;\r","URAD = 1e-6;\r","\r","BAO.TranslationX = NM * str2double(xml.IntraField.Translation.X);\r","BAO.TranslationY = NM * str2double(xml.IntraField.Translation.Y);\r","BAO.Magnification = UM * str2double(xml.IntraField.Magnification);\r","BAO.AsymMagnification = UM * str2double(xml.IntraField.AsymMagnification);\r","BAO.Rotation = URAD * str2double(xml.IntraField.Rotation);\r","BAO.AsymRotation = URAD * str2double(xml.IntraField.AsymRotation);\r","BAO.ExpansionX = UM * str2double(xml.InterField.Expansion.X);\r","BAO.ExpansionY = UM * str2double(xml.InterField.Expansion.Y);\r","BAO.InterfieldRotation = URAD * str2double(xml.InterField.Rotation);\r","BAO.NonOrtho = URAD * str2double(xml.InterField.NonOrthogonality);\r","\r","\r","% sub_parse_WH\r","function IR2EUV = sub_parse_WH(xml)\r","IR2EUV = str2num(xml.Ir2EuvRatioOffset);\r","\r","\r","\r","function grid = sub_parse_grid_new(xml)\r","\r","pitch = sub_parse_xy(xml.Header.Pitch, 1e-3);\r","initial = sub_parse_xy(xml.Header.InitialPosition, 1e-3);\r","numsteps = sub_parse_xy(xml.Header.Steps, 1);\r","\r","xpos = initial.x:pitch.x:(initial.x + (numsteps.x * pitch.x));\r","ypos = initial.y:pitch.y:(initial.y + (numsteps.y * pitch.y));\r","\r","[KAgrid_xw, KAgrid_yw] = meshgrid(xpos, ypos);\r","grid.x                                 = reshape(KAgrid_xw, [], 1);\r","grid.y                                 = reshape(KAgrid_yw, [], 1);\r","\r","g = [xml.Offsets.elt];\r","\r","xg = str2double({g.X});\r","yg = str2double({g.Y});\r","grid.dx = xg' * 1e-9;\r","grid.dy = yg' * 1e-9;\r","\r","invalid_idx = arrayfun(@(x) strcmp(x.valid, 'false'), g)';\r","grid.dx(invalid_idx) = NaN;\r","grid.dy(invalid_idx) = NaN;\r","\r","\r","function SUSD = sub_parse_SUSD(xml)\r","\r","NM = 1e-9;\r","SUSD.TranslationX = NM * str2double(xml.Translation.X);\r","SUSD.TranslationY = NM * str2double(xml.Translation.Y);\r","SUSD.Magnification = NM * str2double(xml.Magnification);\r","SUSD.AsymMagnification = NM * str2double(xml.AsymMagnification);\r","SUSD.Rotation = NM * str2double(xml.Rotation);\r","SUSD.AsymRotation = NM * str2double(xml.AsymRotation);\r","\r","\r","% sub_parse_mirr (parses one map, i.e. a set of (pos, val) combinations\r","function mirr = sub_parse_mirr(xml, pos_name, val_name)\r","start = str2num(xml.Header.InitialPosition) * 1e-3;\r","pitch = str2num(xml.Header.Pitch) * 1e-3;\r","steps = str2num(xml.Header.Steps);\r","mirr.(pos_name) = (pitch * (0:steps)) + start;\r","mirr.(val_name) = arrayfun(@(elt) str2num(elt{1}) * 1e-9, {xml.Offsets.elt});\r","mirr.(pos_name) = (mirr.(pos_name))';\r","mirr.(val_name) = (mirr.(val_name))'; % 401x1 instead of 1x401;\r","\r","\r","% sub_parse_xy: parse a struct with string-valued fields 'X' and 'Y' into a struct with numerical-valued fields 'x' and 'y'\r","function xy = sub_parse_xy(xml, scale)\r","xy.x = str2num(xml.X) * scale;\r","xy.y = str2num(xml.Y) * scale;\r",""],"CoverageData":{"CoveredLineNumbers":[22,25,27,28,30,31,32,34,35,36,37,38,39,40,41,42,43,44,54,60,61,62,63,64,88,89,93,94,96,97,99,100,101,102,107,108,113,120,121,122,124,125,126,127,128,129,130,131,132,133,138,144,145,146,148,149,151,152,153,155,157,158,159,160,162,163,164,180,181,182,183,184,185,186,191,192],"UnhitLineNumbers":[169,170,171,172,173,174,175],"HitCount":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,38,0,0,38,0,38,38,0,38,304,238,0,238,238,38,200,38,162,38,124,10,114,114,0,0,0,0,0,0,0,0,0,38,0,0,0,0,0,38,38,38,38,38,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,38,38,0,0,0,38,38,0,38,38,0,38,38,38,38,0,0,0,0,76,76,0,0,0,0,48,0,0,0,0,0,0,38,38,38,0,38,38,38,38,38,38,38,38,38,38,0,0,0,0,38,0,0,0,0,0,48,48,48,0,48,48,0,48,48,48,0,48,0,48,48,48,48,0,48,48,48,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,152,152,152,152,152,152,152,0,0,0,0,144,144,0]}}