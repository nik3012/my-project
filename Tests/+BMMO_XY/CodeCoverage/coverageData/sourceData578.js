var sourceData578 = {"FileContents":["function [ml_in, ml_out] = bmmo_read_idatsbcinlinesdmsystemreport(idatsbcinline_filepath, adelexposetraj_filepath)\r","% function [ml_in, ml_out] = bmmo_read_idatsbcinlinesdmsystemreport(idatsbcinline_filepath, adelexposetraj_filepath)\r","%\r","% Given the filepath for IDATsbcInlineSdmSystemReportProtected, the function decrypts and parses to 2 ml-structs.\r","%\r","% Input:\r","%   idatsbcinline_filepath               :    IDATsbcInlineSdmSystemReport(Protected) filepath\r","%   adelexposetraj_filepath [Optional]   :    ADELexposureTrajectoriesReportProtected\r","%                                             filepath. Required to obtain y-resampled grid layout.\r","% Output:\r","%   ml_in                                :    System part of the inlineSDM corrections from the input SBC recipe. \r","%                                             ChuckId is contained in ml_in.info.F.chuck_id\r","%   ml_out                               :    The model data output. The system corrections provided to CET after \r","%                                             applying the inlineSDM model.\r","\r","% Load and decrypt the IDATsbcInlineSdmSystemReport\r","parsed_IDAT = bmmo_load_ADEL(idatsbcinline_filepath);\r","\r","% Check whether only a single image is contained within the IDAT\r","nr_of_images = length(parsed_IDAT.SystemModelOutput.RequestedScaledCorrections(1).elt.Corrections);\r","if nr_of_images ~= 1\r","    error('bmmo_read_idatsbcinlinesdmsystemreport currently only supports single images. The supplied IDAT contains multiple/no images')\r","else\r","end\r","\r","% Check whether an ADELexposureTrajectoriesReportProtected is given.\r","if nargin == 2\r","    ADEL_provided = 1;\r","elseif nargin == 1\r","    ADEL_provided = 0;\r","    warning('Only one input given. Assuming 25.4x33.0 mm layout grid. If this is not allowed, provide an ADELexposuretrajectoriesreport')\r","    x_step_out  = 12;\r","    x_pitch_out = 2.12;\r","    x_ini_out   = -12.72;\r","    y_step_out  = 18;\r","    y_pitch_out = 11/6;\r","    y_ini_out   = -16.5;\r","else\r","    error('Incorrect number of input arguments. Check the documentation of this function')\r","end\r","\r","% Populate metadata.\r","ml_in.nmark              = length(parsed_IDAT.SystemModelInput.Corrections(1).elt.Offsets);\r","ml_in.nlayer             = 1;\r","ml_in.nfield             = length(parsed_IDAT.SystemModelOutput.RequestedScaledCorrections(1).elt.Corrections);\r","ml_in.nwafer             = length(parsed_IDAT.SystemModelInput.Corrections);\r","ml_in.info.machine_type  = parsed_IDAT.Header.MachineType;\r","ml_in.info.MachineID     = parsed_IDAT.Header.MachineID;\r","ml_in.info.LotStarttime  = parsed_IDAT.DocumentMetaData.LotStartTime;\r","\r","% Extract the chuckid order and place in info.F.chuck_id\r","for index = 1 : length(parsed_IDAT.SystemModelInput.Corrections)\r","    ml_in.info.F.chuck_id{index} = parsed_IDAT.SystemModelInput.Corrections(index).elt.Header.ChuckId;\r","end\r","\r","% Create the second output ml-struct and append tlgname to ml-structs.\r","ml_out  = ml_in;\r","ml_in.tlgname     = 'InlineSDM System part input';\r","ml_out.tlgname    = 'InlineSDM System part output';\r","\r","% First ml_in is populated.\r","% Grid layout is constructed using information contained in the IDAT, which is obtained here.\r","y_step  = str2double(parsed_IDAT.SystemModelInput.Corrections(1).elt.Header.Steps.Y);\r","x_step  = str2double(parsed_IDAT.SystemModelInput.Corrections(1).elt.Header.Steps.X);\r","y_ini   = str2double(parsed_IDAT.SystemModelInput.Corrections(1).elt.Header.InitialPosition.Y);\r","x_ini   = str2double(parsed_IDAT.SystemModelInput.Corrections(1).elt.Header.InitialPosition.X);\r","y_pitch = str2double(parsed_IDAT.SystemModelInput.Corrections(1).elt.Header.Pitch.Y);\r","x_pitch = str2double(parsed_IDAT.SystemModelInput.Corrections(1).elt.Header.Pitch.X);\r","\r","% Create the grid for ml_in using several sub-functions.\r","% Be aware: xf and yf are meandering from starting from the bottom left to the bottom right.\r","ml_in.wd.xf = sub_xf_matrix(x_step, y_step, x_pitch, x_ini);\r","ml_in.wd.yf = sub_yf_matrix(x_step, y_step, y_pitch, y_ini);\r","ml_in.wd.xc = zeros(ml_in.nmark, 1);\r","ml_in.wd.yc = zeros(ml_in.nmark, 1);\r","ml_in.wd.xw = ml_in.wd.xf + ml_in.wd.xc;\r","ml_in.wd.yw = ml_in.wd.yf + ml_in.wd.yc;\r","\r","% Populate dx and dy for ml_in. \r","ml_in = sub_get_dx_dy(ml_in, parsed_IDAT, \"in\", x_step, y_step);\r","\r","% Next, populate ml_out.\r","% If ADELExposureTrajectoriesReport is provided the y-resampled CET grid is obtained from the ADEL. \r","% The ADEL is loaded and the correct grid layout is extracted using sub_xf_yf_ADELtraject.\r","if ADEL_provided\r","    xml_data                       = bmmo_load_ADEL(adelexposetraj_filepath);\r","    [ml_out.wd.xf, ml_out.wd.yf ]  = sub_xf_yf_ADELtraject(xml_data, ml_out.nmark, x_step, y_step);\r","    \r","% If no ADEL is provided, the 25.4x33.0 mm CET grid is automatically assumed. \r","% This is calculated using the previously determined values.\r","else\r","    ml_out.wd.xf = sub_xf_matrix(x_step_out, y_step_out, x_pitch_out, x_ini_out);\r","    ml_out.wd.yf = sub_yf_matrix(x_step_out, y_step_out, y_pitch_out, y_ini_out);                                    \r","end\r","\r","% Populate xc, yc, xw and yw. Be aware: since we are regarding intrafield, xc and yc are hardcoded to be zero.\r","ml_out.wd.xc = zeros(ml_out.nmark, 1);\r","ml_out.wd.yc = zeros(ml_out.nmark, 1);\r","ml_out.wd.xw = ml_out.wd.xf + ml_out.wd.xc;\r","ml_out.wd.yw = ml_out.wd.yf + ml_out.wd.yc;\r","    \r","% Populate dx and dy for ml_out.\r","ml_out = sub_get_dx_dy(ml_out, parsed_IDAT, \"out\", x_step, y_step);\r","\r","end\r","\r","\r","\r","function yf_mat = sub_yf_matrix(x_step, y_step, y_pitch, y_ini)\r","% Generate the matrix for yf: a 13x19 field with the y-coordinates as values. \r","for index = 1 : x_step + 1\r","    yf_mat(:, index) = linspace(y_ini, y_ini + y_step * y_pitch, y_step + 1) * 1e-3;\r","end\r","yf_mat = reshape(yf_mat', [], 1);\r","\r","end\r","\r","function xf_mat = sub_xf_matrix(x_step, y_step, x_pitch, x_ini)\r","% Generate the matrix for xf: a meandering 13x19 field with the x-coordinates as values. Due to the meandering uneven rows are flipped.\r","for index = 1 : y_step + 1\r","    if mod(index, 2)\r","        xf_mat(index, :) = linspace( x_ini, x_ini + (x_step * x_pitch), x_step + 1) * 1e-3;\r","    else\r","        xf_mat(index, :) = linspace( x_ini + (x_step * x_pitch), x_ini, x_step + 1) * 1e-3;\r","    end\r","end\r","xf_mat = reshape(xf_mat', [], 1);\r","\r","end\r","\r","function out = sub_linear_to_meander(column, x_step, y_step)\r","% Sub-function to meander the data. The data is placed in a 13x19 matrix, then\r","% the uneven rows are flipped and the matrix is made into a column vector\r","% again.\r","to_matrix = reshape(column, [x_step + 1, y_step + 1]);\r","for index = 1 : size(to_matrix, 2)\r","    if ~mod(index, 2)\r","        to_matrix(:, index) = flip(to_matrix(:, index));\r","    else\r","    end\r","end\r","out = reshape(to_matrix, 1, [])';\r","\r","end\r","\r","function [out_x, out_y] = sub_xf_yf_ADELtraject(xml_data, nmark, x_step, y_step)\r","% Sub-function to determine the grid with 247 marks in\r","% ADELexposuretrajectoriesreport, grab the coordinates and place them in a\r","% meandering column vector.\r","for index = 1 : length(xml_data.Input.GridList)\r","    field_information(index, 1) = length(xml_data.Input.GridList(index).elt.GridDefinition);\r","end\r","field_index = find(field_information(:, 1) == 247);\r","\r","for index = 1 : nmark\r","    x_column_holder(index, 1) = str2num(xml_data.Input.GridList(field_index).elt.GridDefinition(index).elt.X) * 1e-3;\r","    y_column_holder(index, 1) = str2num(xml_data.Input.GridList(field_index).elt.GridDefinition(index).elt.Y) * 1e-3;\r","end\r","out_x = sub_linear_to_meander(x_column_holder, x_step, y_step);\r","out_y = sub_linear_to_meander(y_column_holder, x_step, y_step);\r","\r","end\r","\r","function ml = sub_get_dx_dy(ml, parsed_IDAT, type, x_step, y_step)\r","% Sub-function to extract the data from parsed_IDAT. Type is\r","% used to distinguish between the input- and output data\r","if string(type) == \"in\"\r","    fhandle = @(i_wafer, i_mark, XY) (str2double(parsed_IDAT.SystemModelInput.Corrections(i_wafer).elt.Offsets(i_mark).elt.(XY)) * 1e-9);\r","elseif string(type) == \"out\"\r","    fhandle = @(i_wafer, i_mark, XY) (str2double(parsed_IDAT.SystemModelOutput.RequestedScaledCorrections(i_wafer).elt.Corrections.elt.Offsets(i_mark).elt.(XY)) * 1e-9);\r","else\r","    error('Wrong type provided. Only \"in\" and \"out\" are allowed, but found: %s', string(type));\r","end\r","\r","for i_wafer = 1 : ml.nwafer\r","    for i_mark = 1 : ml.nmark\r","        column_x(i_wafer, i_mark) = feval(fhandle, i_wafer, i_mark, 'X');\r","        column_y(i_wafer, i_mark) = feval(fhandle, i_wafer, i_mark, 'Y');\r","    end\r","ml.layer.wr(i_wafer).dx = sub_linear_to_meander(column_x(i_wafer, :), x_step, y_step);\r","ml.layer.wr(i_wafer).dy = sub_linear_to_meander(column_y(i_wafer, :), x_step, y_step);\r","end\r","\r","end"],"CoverageData":{"CoveredLineNumbers":[17,20,21,23,27,28,29,30,31,32,33,34,35,36,37,43,44,45,46,47,48,49,52,53,57,58,59,63,64,65,66,67,68,72,73,74,75,76,77,80,85,86,87,91,92,93,97,98,99,100,103,111,112,114,120,121,122,123,124,127,135,136,137,138,139,142,150,151,153,155,156,157,159,160,167,168,169,170,175,176,177,178,180,181],"UnhitLineNumbers":[22,38,39,171,172],"HitCount":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,2,2,0,2,0,0,0,2,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,2,2,2,2,2,2,2,0,0,2,4,0,0,0,2,2,2,0,0,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,2,0,0,0,0,2,1,1,0,0,0,1,1,1,0,0,0,2,2,2,2,0,0,2,0,0,0,0,0,0,0,3,39,0,3,0,0,0,0,0,3,57,30,27,27,0,0,3,0,0,0,0,0,0,0,18,18,342,162,180,0,0,18,0,0,0,0,0,0,0,1,34,0,1,0,1,247,247,0,1,1,0,0,0,0,0,0,4,2,2,2,0,0,0,0,4,8,1976,1976,0,8,8,0,0,0]}}