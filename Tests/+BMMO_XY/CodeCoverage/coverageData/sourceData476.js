var sourceData476 = {"FileContents":["function bmmo_assert_SBC_equal(sbc_struct1, sbc_struct2, out_file, ADEL_prec, tol, show_NOKs)\r","% function bmmo_assert_SBC_equal(sbc_struct1, sbc_struct2, out_file, ADEL_prec, tol, show_NOKs)\r","%\r","% Assert MATLAB and LIS SBCs as per the given spec\r","%\r","% Inputs:\r","% sbc_struct1 : out.corr, output of bmmo_nxe_drift_control_model \r","% sbc_struct2 : LIS/OTAS SBC recipe parsed using bmmo_kt_process_SBC2\r","%\r","%\r","% Optional input:\r","% outfile: filename to output the assertion results,\r","% eg: 'output.txt' or provide outfile = stdout for printing to command line\r","% ADEL_prec, change precision of sbc_strcut as per ADEL schema, default is 1\r","% tol: tolerance for assertion of SBCs, default: 5e-13\r","% show_NOKs: List only NOKs from assertion if set to 1, default is 0\r","%\r","%20210107 ANBZ Creation\r","\r","prev_state = warning('query', 'backtrace');\r","warning('backtrace', 'off');\r","\r","title = 'sbc_struct 1 vs sbc_struct 2';\r","\r","if nargin < 3\r","    outfile = stdout;\r","else\r","    if ischar(out_file)\r","        outfile = fopen(out_file, 'w');\r","        if contains(out_file, 'MATLABvsLIS')\r","            title = 'MATLAB vs LIS';\r","        end\r","    else\r","        outfile = out_file;\r","    end\r","end\r","\r","if nargin < 4\r","    ADEL_prec = 1;\r","end\r","\r","if nargin < 5\r","    tol = 5e-13;\r","end\r","\r","if nargin < 6\r","    show_NOKs = 0;\r","end\r","\r","% SBC\r","fprintf(outfile,['SBCs: ', title,'\\n\\n']);\r","\r","if ADEL_prec == 1\r","    sbc_struct1 = bmmo_convert_SBC_to_ADELprecision(sbc_struct1);\r","else\r","    sbc_struct1 = sub_remove_config(sbc_struct1);\r","    sbc_struct2 = sub_remove_config(sbc_struct2);\r","end\r","\r","if length(sbc_struct1.KA.grid_2de(1).dx) == length(sbc_struct2.KA.grid_2de(1).dx)\r","    [sbc_struct1.KA, sbc_struct2.KA] = sub_check_valids(sbc_struct1.KA, sbc_struct2.KA, outfile);\r","end\r","\r","fprintf(outfile, [' (Delta expected to be less than : ' ,num2str(tol), ')\\n']);\r","sub_assertion(sbc_struct1, sbc_struct2, outfile, tol, show_NOKs)\r","\r","fclose('all');\r","warning(prev_state);\r","end\r","\r","\r","\r","% SUB FUNCTIONS\r","function sub_warning(message, outfile)\r","\r","if outfile == 1 %stdout case\r","    warning(message)\r","else % filename char case\r","    warning(message)\r","    fprintf(outfile, ['WARNING:', message,'\\n']);\r","end\r","end\r","\r","\r","function sub_assertion(sbc1, sbc2, outfile, delta, show_NOKs)\r","\r","try\r","    bmmo_assert_equal(sbc1, sbc2, delta, outfile, show_NOKs);\r","catch ME\r","    if strcmp(ME.identifier,'MATLAB:assertion:failed')\r","        sub_warning( 'Assertion Failed! Check the NOKs.', outfile);\r","    else\r","        rethrow(ME)\r","    end\r","end\r","\r","end\r","\r","function sbc = sub_remove_config(sbc)\r","if isfield(sbc,'Configurations')\r","    sbc = rmfield(sbc,'Configurations');\r","end\r","end\r","\r","function [KA1, KA2] = sub_check_valids(KA1, KA2, outfile)\r","\r","if isfield(KA1, 'grid_2dc')\r","    fdname = {'grid_2de', 'grid_2dc'};\r","else\r","    fdname = {'grid_2de'};\r","end\r","\r","for ii =1:length(fdname)\r","    \r","    for i = 1:length(KA1.(fdname{ii}))\r","        dx1_valids(i) = sum(~isnan(KA1.(fdname{ii})(i).dx));\r","        dy1_valids(i) = sum(~isnan(KA1.(fdname{ii})(i).dy));\r","        dx2_valids(i) = sum(~isnan(KA2.(fdname{ii})(i).dx));\r","        dy2_valids(i) = sum(~isnan(KA2.(fdname{ii})(i).dy));\r","    end\r","    \r","    if ~isequal(dx1_valids(1), dy1_valids(1), dx2_valids(1), dy2_valids(1))\r","        \r","        sub_warning([(fdname{ii}) ' :sbc_struct1 and sbc_struct2 have different number of valids, choosing common marks for assertion'], outfile)\r","        \r","        fprintf(outfile, [fdname{ii},'             Ch1 dx  Ch1 dy  Ch2 dx  Ch2 dy\\n']);\r","        fprintf(outfile, ['sbc_struct1 valids : ',num2str([dx1_valids(1), dy1_valids(1), dx1_valids(2), dy1_valids(2)]),'\\n']);\r","        fprintf(outfile, ['sbc_struct2 valids : ',num2str([dx2_valids(1), dy2_valids(1), dx2_valids(2), dy2_valids(2)]),'\\n\\n']);\r","        \r","        if isequal(dx1_valids(1), dy1_valids(1)) && isequal(dx2_valids(1), dy2_valids(1))\r","            \r","            if dx1_valids(1) < dx2_valids(2)\r","                \r","                for i =1:length(KA1.(fdname{ii}))% KA1 lowest valids case\r","                    KA2.(fdname{ii})(i).dx = KA1.(fdname{ii})(i).dx*0 + KA2.(fdname{ii})(i).dx;\r","                    KA2.(fdname{ii})(i).dy = KA1.(fdname{ii})(i).dy*0 + KA2.(fdname{ii})(i).dy;\r","                end\r","                \r","            else\r","                \r","                for i =1:length(KA1.(fdname{ii}))% KA2 lowest valids case\r","                    KA1.(fdname{ii})(i).dx = KA2.(fdname{ii})(i).dx*0 + KA1.(fdname{ii})(i).dx;\r","                    KA1.(fdname{ii})(i).dy = KA2.(fdname{ii})(i).dy*0 + KA1.(fdname{ii})(i).dy;\r","                end\r","            end\r","            \r","        else\r","            error('Number of valids for dx and dy are different')\r","            \r","        end\r","        \r","    end\r","    \r","end\r","\r","end\r","\r","\r",""],"CoverageData":{"CoveredLineNumbers":[],"UnhitLineNumbers":[20,21,23,25,26,27,28,29,30,31,33,34,38,39,42,43,46,47,51,53,54,55,56,57,60,61,64,65,67,68,76,77,78,79,80,87,88,89,90,91,92,93,100,101,107,108,109,110,113,115,116,117,118,119,122,124,126,127,128,130,132,134,135,136,139,141,142,143,147,148],"HitCount":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}}