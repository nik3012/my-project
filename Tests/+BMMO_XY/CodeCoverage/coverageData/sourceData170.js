var sourceData170 = {"FileContents":["function ml_out = bmmo_resample(mli, ml_target, options, collect_tol)\r","% function ml_out = bmmo_resample(mli, ml_target, options, collect_tol)\r","%  \r","%   Interpolates the input data (ml_in) to another layout (ml_target). \r","%  \r","%   For instance, it can be used to downsample 13x19 to say 7x7, dyna25, etc.\r","%   But also the other way around: to upsample e.g. DYNA25 to 13x19 by means \r","%   of interpolation. \r","%  \r","%   NOTE:\r","%    * half-invalid marks (only dx or dy NaN) are not supported\r","%  \r","%   Input:\r","%     ml_in                      : input overlay data to be interpolated\r","%     ml_target                  : data set with template layout\r","%     options                    : options structure with following fields:\r","%       interp_type              : interpolation type for\r","%                                       bmmo_interp2_dxdydz\r","%                                   'nearest', 'linear', 'bilinear', 'cubic', 'gauss'\r","%       bounding box             : if numeric, a bounding box of the specified size will be added\r","%                                   to the input data. It is the\r","%                                   responsibility of the caller to ensure\r","%                                   that the input data is contained in the\r","%                                   bounding box\r","%       nan_interpolation       : interpolation type for removing NaNs from\r","%                                   input data. 'near4' for iterative\r","%                                   4-nearest-neighbour algorithm.\r","%                                   'diagonal' for 8-nearest-neighbour.\r","%                                   Any other string for no NaN\r","%                                   interpolation.\r","%       gauss_radius            : optional radius for Gaussian\r","%                                   interpolation.\r","%       wafersize               : diameter of the wafer. Points outside this\r","%                                   diameter will have their values set to\r","%                                   NaN.\r","%   Input optional:\r","%       collect_tol             : tolerance thereshold to sort wafer\r","%                                 coordinates\r","%  \r","%   Output:\r","%     ml_out                     : interpolated data\r","\r","ml_out = ml_target;\r","\r","if isnumeric(options.bounding_box)\r","    ml_in_bb = bmmo_add_bounding_box(mli, options.bounding_box);\r","else\r","    ml_in_bb = mli;\r","end\r","\r","if nargin > 3\r","    ilayout = sort2d(ml_in_bb.wd.xw, ml_in_bb.wd.yw, collect_tol);\r","    olayout = sort2d(ml_out.wd.xw , ml_out.wd.yw, collect_tol);\r","else\r","    ilayout = sort2d(ml_in_bb.wd.xw, ml_in_bb.wd.yw);\r","    olayout = sort2d(ml_out.wd.xw , ml_out.wd.yw);\r","end\r","\r","for it_layer = 1:ml_in_bb.nlayer\r","    for it_wafer = 1:ml_in_bb.nwafer\r","        \r","        input_wr = ml_in_bb.layer(it_layer).wr(it_wafer);\r","\r","        input_mesh.dx     = ilayout.meshgrid.x * nan;\r","        input_mesh.dy     = input_mesh.dx;\r","\r","        lidx = ilayout.idx > 0;\r","        input_mesh.dx(lidx) = input_wr.dx(ilayout.idx(lidx));\r","        input_mesh.dy(lidx) = input_wr.dy(ilayout.idx(lidx));\r","        \r","        %  fill NaNs if needed \r","        if strcmp(options.nan_interpolation, 'diagonal')\r","              input_mesh.dx = bmmo_interp_nans(input_mesh.dx, ilayout.sorted.x, ilayout.sorted.y, 'diagonal', 1);\r","              input_mesh.dy = bmmo_interp_nans(input_mesh.dy, ilayout.sorted.x, ilayout.sorted.y, 'diagonal', 1);\r","%               input_mesh.dx = interp_nans(input_mesh.dx, ilayout.sorted.x, ilayout.sorted.y);\r","%               input_mesh.dy = interp_nans(input_mesh.dy, ilayout.sorted.x, ilayout.sorted.y);\r","              \r","        elseif strcmp(options.nan_interpolation, 'near4')\r","              input_mesh.dx = bmmo_interp_nans(input_mesh.dx, ilayout.sorted.x, ilayout.sorted.y, 'updown', 1);\r","              input_mesh.dy = bmmo_interp_nans(input_mesh.dy, ilayout.sorted.x, ilayout.sorted.y, 'updown', 1);\r","%              input_mesh.dx = interp_nans(input_mesh.dx, ilayout.sorted.x, ilayout.sorted.y);\r","%              input_mesh.dy = interp_nans(input_mesh.dy, ilayout.sorted.x, ilayout.sorted.y);\r","        end\r","\r","        % interpolate\r","        [ml_out.layer(it_layer).wr(it_wafer).dx, ml_out.layer(it_layer).wr(it_wafer).dy] = bmmo_interp2_dxdydz(input_mesh, ilayout, olayout, options);\r","\r","        % filter anything outside intended area\r","        idx_outer = find((ml_out.wd.xw.^2 + ml_out.wd.yw.^2) > (options.wafersize*0.5)^2);\r","        ml_out.layer(it_layer).wr(it_wafer).dx(idx_outer) = NaN;\r","        ml_out.layer(it_layer).wr(it_wafer).dy(idx_outer) = NaN;\r","    end\r","end\r",""],"CoverageData":{"CoveredLineNumbers":[43,45,46,47,48,51,52,53,54,55,56,59,60,62,64,65,67,68,69,72,73,74,78,79,80,86,89,90,91],"UnhitLineNumbers":[],"HitCount":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2495,0,2495,2122,373,373,0,0,2495,1736,1736,759,759,759,0,0,2495,2495,0,8657,0,8657,8657,0,8657,8657,8657,0,0,8657,7448,7448,0,0,0,1209,4,4,0,0,0,0,0,8657,0,0,8657,8657,8657,0,0,0]}}