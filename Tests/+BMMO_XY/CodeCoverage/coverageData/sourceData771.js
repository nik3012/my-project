var sourceData771 = {"FileContents":["\r","function ml = bmmo_wm2ovl(wm,mli,sigma)\r","% function ml = bmmo_wm2ovl(wm,mli)\r","%\r","% convert wafer map to overlay structure\r","% (optimization for BMMO-NXE)\r","%\r","% Input: wm: wafer map structure (source)\r","%        mli: overlay structure to map to\r","%\r","% Optional input: sigma\r","%\r","% Output: \r","%   ml: overlay structure, same layout as mli, containing\r","%       wafer map data\r","%\r","% 20160829 SBPR Adapted from ovl_wm2ovl.m, vectorized\r","\r","if nargin < 3\r","    sigma = 3e-3; \r","end\r","\r","nwafer = length(wm.wr);\r","ml.wd  = mli.wd;\r","ml.nwafer = nwafer;\r","ml.nlayer = 1;\r","ml.nfield = mli.nfield;\r","ml.nmark  = mli.nmark;\r","\r","for iwafer = 1:nwafer\r","    nr_areas = length(wm.wr(iwafer).areas);\r","\r","    % get the size of the x, y z vectors\r","    xsz = zeros(1, nr_areas);\r","    ysz = xsz';\r","    for ia = 1:nr_areas;\r","        xsz(ia) = length(wm.wr(iwafer).areas(ia).x);\r","        ysz(ia) = length(wm.wr(iwafer).areas(ia).y);\r","    end\r","    \r","    vsz = xsz * ysz;         % vector size\r","    asz = diag(xsz' * ysz'); % area size\r","    \r","    % allocate the vectors\r","    x = zeros(vsz, 1);\r","    y = x;\r","    z = x;\r","    \r","    offset = 1;\r","\r","    for ia = 1:nr_areas       \r","        [xg, yg] = meshgrid(wm.wr(iwafer).areas(ia).x, wm.wr(iwafer).areas(ia).y');\r","        \r","        v_end = sum(asz(1:ia));\r","        \r","        x(offset:v_end) = xg(:);\r","        y(offset:v_end) = yg(:);\r","        wm.wr(iwafer).areas(ia).z(~wm.wr(iwafer).areas(ia).valid) = NaN;\r","        z(offset:v_end) = wm.wr(iwafer).areas(ia).z(:);\r","        offset = v_end + 1;\r","    end\r","\r","    [z, fx, fy] = interp2dg_opt(x, y, z, ml.wd.xw, ml.wd.yw, sigma);\r","\r","    ml.layer(1).wr(iwafer).dx =  fx*0.775e-3/2;\r","    ml.layer(1).wr(iwafer).dy =  fy*0.775e-3/2;\r","    id = find(isnan(mli.layer(1).wr(iwafer).dx));\r","    ml.layer(1).wr(iwafer).dy(id) = nan;\r","    id = find(isnan(mli.layer(1).wr(iwafer).dy));\r","    ml.layer(1).wr(iwafer).dx(id) = nan;\r","\r","end\r","\r","\r","function [zi,zxi,zyi] = interp2dg_opt(X,Y,Z,x,y,s)\r","%INTERP2DG 2D Gaussian interpolation\r","%\r","% Usage: [zi,zxi,zyi] = INTERP2DG(X,Y,Z,x,y,s)\r","%\r","% See also: GAUSS2D\r","% \r","% 20160831 SBPR Added optimised approximation using knnsearch\r","\r","\r","n    = length(x(:));\r","zi   = zeros(size(x));\r","zxi  = zeros(size(x));\r","zyi  = zeros(size(x));\r","\r","% Assume that less than 500 marks will be within 3sigma distance\r","[I, D] = knnsearch([X Y], [x y], 'k', 500);\r","s3 = 3*s;\r","\r","for k=1:n\r","    xk    = x(k);\r","    yk    = y(k);\r","    idx = I(k, :);\r","    idx = idx(D(k,:) < s3);\r","    valid = find(~isnan(Z(idx)));\r","    if (length(valid)>1)\r","        idx   = idx(valid);\r","        Xi    = X(idx)-xk;\r","        Yi    = Y(idx)-yk;\r","        Zi    = Z(idx);\r","        Wi    = gauss2d(Xi,Yi,s);\r","        A = [Wi,Wi.*Xi,Wi.*Yi];\r","        [Ai,r] = pseudoinverse(A); \r","        if (r==3)\r","            b = Ai*(Zi.*Wi);\r","            zi(k) =b(1);\r","            zxi(k)=b(2);\r","            zyi(k)=b(3);\r","        else    \r","            zi(k) =nan;\r","            zxi(k)=nan;\r","            zyi(k)=nan;\r","        end\r","    end\r","end\r",""],"CoverageData":{"CoveredLineNumbers":[19,20,23,24,25,26,27,28,30,31,34,35,36,37,38,41,42,45,46,47,49,51,52,54,56,57,58,59,60,63,65,66,67,68,69,70,85,86,87,88,91,92,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112],"UnhitLineNumbers":[113,114,115,116],"HitCount":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,6,0,0,6,6,6,78,78,0,0,6,6,0,0,6,6,6,0,6,0,6,78,0,78,0,78,78,78,78,78,0,0,6,0,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,0,0,6,6,0,6,46572,46572,46572,46572,46572,46572,46572,46572,46572,46572,46572,46572,46572,46572,46572,46572,46572,46572,0,0,0,0,0,0,0,0]}}