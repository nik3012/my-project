var sourceData16 = {"FileContents":["function [ml_apply, ml_res, ml_cet_nce] = bmmo_KA_LOC_CET_fingerprint(ka_grid, ml_input, options)\r","% function [ml_apply, ml_res, ml_cet_nce] = bmmo_KA_LOC_CET_fingerprint(ka_grid, ml_input, options)\r","%\r","% Given the modelled KA grid in testlog format, get the KA fingerprint\r","% after LOC and CET actuation\r","%\r","% Input:\r","%   ka_grid: KA grid in testlog format\r","%   ml_input: input ml structure\r","%   options: structure containing at least the following field:\r","%       fieldsize: 1 * 2 array with x and y fieldsize\r","%       CET_marklayout\r","%       wafer_radius_in_mm\r","%       KA_actuation.type\r","%       \r","% Output:\r","%   ml_apply: KA fingerprint after LOC and CET actuation\r","%\r","% Optional Outputs:\r","%   ml_res : KA residual after LOC correction and CET actuation\r","%   ml_cet_nce: KA CET actuation residual(only)\r","\r","\r","ml_cet_input = ovl_create_dummy(ml_input, 'marklayout', options.CET_marklayout, 'edge', options.wafer_radius_in_mm);\r","ml_out_F = ovl_create_dummy(ml_input, 'edge', options.wafer_radius_in_mm);\r","\r","ml_cet_loc_corr = bmmo_KA_LOC_fingerprint(ka_grid, ml_cet_input, options); % LOC corrrection in CET layout\r","[~, cs] = bmmo_cet_model(ml_cet_loc_corr, options.KA_actuation.type);% CET actuation in CET layout\r","cs = arrayfun(@(x) x.poly2spline(), cs);\r","ml_apply = bmmo_cet_model(ml_out_F, cs, options.KA_actuation.type, 'return_corrections', true); % replay trajectories on ml_out_F layout/meas layout\r","\r","if nargout > 1\r","    [ml_loc_corr, ml_loc_res] = bmmo_KA_LOC_fingerprint(ka_grid, ml_input, options);\r","    ml_cet_nce = ovl_sub(ml_loc_corr, ml_apply); %CET NCE with KA LOC corrected input\r","    ml_res = ovl_add(ml_loc_res, ml_cet_nce); % add LOC res and CET nce\r","end\r","\r",""],"CoverageData":{"CoveredLineNumbers":[],"UnhitLineNumbers":[24,25,27,28,29,30,32,33,34,35],"HitCount":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}}