var sourceData765 = {"FileContents":["function [ml, outliers] = bmmo_simulate_contamination(ml_layout, varargin) \r","% Simulate contamination and outliers. Used in testing outlier removal.\r","%\r","% BWAS 2014-05-06 Script to add contamination sources to ml struct.\r","% Sources:\r","%   - noise (white)\r","%   - single mark outliers\r","%   - particle spot (using a simple physical model)\r","%\r","% Usage:\r","%   Adds white noise with maximum overlay errors of 2 nm\r","%   ml = ovl_metro_simulate_contamination(ml_layout, 'noise', 2)\r","%\r","%   Adds 5 single mark outliers at random places on the wafer\r","%   ml = ovl_metro_simulate_contamination(ml_layout, 'outliers', 5)\r","%\r","%   Adds 3 particles with size 40 um at random places on the wafer\r","%   ml = ovl_metro_simulate_contamination(ml_layout, 'particles', 3, 'particle_size', 40})\r","%\r","% 2014-05-06 JFEI creation for new outlier removal prototyping\r","% 2014-05-06 BWAS Added (white) noise and single mark ourlier sources\r","% 2014-05-07 BWAS Added physical model for particles\r","% 2014-06-20 BWAS Added radial noise (xy no longer independent), some fixes\r","% 2015-07-03 SoNa added more physics to particle model\r","% 2015-07-05 SoNa bugfix\r","% 2016-08-31 SBPR Vectorized some loops, modified for BMMO-NXE\r","\r","\r","   %% Defaults and handling of input arguments\r","   options.flags                 = {'radial_noise'};\r","   options.wafers                = 0;   % Set default wafers, all wafers [1:6]\r","   options.noise                 = 0;   % Set default white noise error to 0 nm\r","   options.radial_noise          = 0;   % Can set noise generation to be xy-dependent\r","   options.outliers              = 0;   % Set default number of outliers\r","   options.outliers_error        = 100; % Set default outliers to 100 nm (2 sigma)\r","   options.particles             = 0;   % Set default number of particles\r","   options.spots_definition      = {}; %'random'; % Use cell array consisting of triples (xw,yw,spotsize) to override\r","   options.particle_size         = 10;  % Set default particle size to 10 um\r","   \r","   options.random_seed_noise     = 234; % Set random seed (for consistent testing)\r","                                        % Fully random, set seed to 0 (zero).\r","   options.random_seed_outliers  = 567; % Set random seed (for consistent testing)\r","                                        % Fully random, set seed to 0 (zero).\r","   options.random_seed_particles = 907; % Set random seed (for consistent testing)\r","                                        % Fully random, set seed to 0 (zero).\r","\r","   [options, args] = ovl_parse_options(options, varargin{:});\r","\r","   % Units\r","   scale_noise                   = 1e-9; % nm\r","   scale_outlier                 = 1e-9; % nm\r","   scale_particle                = 1e-6; % um\r","   \r","   %% Set output (no contamination)\r","   ml                            = ml_layout;\r","   outliers                      = [];\r","   \r","   wafers = options.wafers;\r","   if wafers == 0\r","      wafers = 1:ml.nwafer;\r","   end\r","\r","   \r","   %% Generate white noise source\r","   if (options.noise > 0)\r","      % Set random seed\r","      if (options.random_seed_noise ~= 0)\r","          rng('default');\r","          rng(options.random_seed_noise);\r","      end\r"," \r","      % Add white noise\r","      % For each mark in every layer:\r","      % - determine overlay error & direction\r","      % - apply error to mark\r","      for l = 1:ml.nlayer\r","         for w = 1:length(wafers)\r","            \r","            if options.radial_noise\r","                noise = options.noise * randn(size(ml.wd.xw)) * scale_noise;\r","                direction = 2 * pi * rand(size(ml.wd.xw)); \r","                ml.layer(l).wr(wafers(w)).dx = ml.layer(l).wr(wafers(w)).dx + cos(direction) .* noise;\r","            else\r","                % Distribute over x and y independently (gives Gaussian\r","                % distrution in x, y)\r","                noise_x = options.noise * randn(size(ml.wd.xw)) * scale_noise;\r","                noise_y = options.noise * randn(size(ml.wd.xw)) * scale_noise;\r","\r","                ml.layer(l).wr(wafers(w)).dx = ml.layer(l).wr(wafers(w)).dx + noise_x;\r","                ml.layer(l).wr(wafers(w)).dy = ml.layer(l).wr(wafers(w)).dy + noise_y;\r","            end\r","\r","         end\r","      end\r","   end\r","\r","   %% Generate outliers source\r","   if (options.outliers > 0)\r","      % Set random seed\r","      if (options.random_seed_outliers ~= 0)\r","         rng('default');\r","         rng(options.random_seed_outliers);\r","      end\r","      \r","      % For each outlier\r","      % - determine layer\r","      % - determine wafer\r","      % - determine mark within layer/wafer\r","      % - determine overlay error & direction\r","      % - apply error to mark --> outlier\r","\r","      for w = 1:length(wafers)\r","         errors = [];\r","\r","         for o = 1:options.outliers\r","            % Set layer\r","            l = randi([1, ml.nlayer]);\r","    \r","            unique_mark = false;\r","\r","            while ~unique_mark\r","               m = randi([1, length(ml.layer(l).wr(wafers(w)).dx)]);\r","\r","               % Check for NaN\r","               if isnan(ml.layer(l).wr(wafers(w)).dx(m))\r","                  continue;\r","               end\r","                   \r","               % Check if mark not already defined as outlier\r","               if (~isempty(errors))\r","                  lay_id = errors(:, 1) == l;\r","                  unique_mark = isempty(find(errors(lay_id, 2) == m, 1));\r","               else\r","                  unique_mark = true;\r","               end\r","\r","               if (unique_mark)\r","                  % Add to known outliers\r","                  errors = [errors; [l, m]];\r","\r","                  % Set outlier\r","                  ol_size = options.outliers_error * randn(1) * scale_outlier;\r","                  direction = 2 * pi * rand(1);\r","\r","                  ml.layer(l).wr(wafers(w)).dx(m) = ml.layer(l).wr(wafers(w)).dx(m) + cos(direction) * ol_size;\r","                  ml.layer(l).wr(wafers(w)).dy(m) = ml.layer(l).wr(wafers(w)).dy(m) + sin(direction) * ol_size;\r","\r","                  % Move to next outlier\r","                  unique_mark = true;\r","               end\r","            end\r","         end\r","         \r","         outliers.wafer(w).errors = errors;\r","      end\r","   end\r","   \r","   %% Generate particle source\r","   if (options.particles > 0)\r","       if ~isempty(options.spots_definition) % if definition is given, go with new model\r","           ml = add_dirt(ml,options.spots_definition);\r","       else % go with old model\r","           \r","           % Set random seed\r","           if (options.random_seed_particles ~= 0)\r","               rng('default');\r","               rng(options.random_seed_particles);\r","           end\r","           \r","           % For each particle\r","           % - determine position (independent of marks) within layer\r","           % - determine marks affected by particle\r","           % - determine overlay error & direction per mark\r","           % - apply errors to marks on all layers\r","           \r","           for w = 1:length(wafers)\r","               particles = [];\r","               \r","               for p = 1:options.particles\r","                   unique_position = false;\r","                   \r","                   while ~unique_position\r","                       % Determine position on wafer, taking wafer size as possible\r","                       % position (could argue to use more or less to represent particles\r","                       % outside the wafer, or only particles fullly on the wafer, respectively.\r","                       radius = 0.150 * (1 - rand(1).^2); % Square to distribute equal over wafer surface\r","                       direction = 2 * pi * rand(1);\r","                       \r","                       p_dx = radius * cos(direction);\r","                       p_dy = radius * sin(direction);\r","                       \r","                       % Check if particle not too close to existing particle\r","                       if (~isempty(particles))\r","                           unique_position = true;\r","                           \r","                           for ppos = 1:size(particles, 1)\r","                               distance = sqrt((particles(ppos, 1) - p_dx)^2 + (particles(ppos, 2) - p_dy)^2);\r","                               \r","                               % Check distance to size of particles\r","                               if (distance < options.particle_size * scale_particle)\r","                                   unique_position = false;\r","                                   break;\r","                               end\r","                           end\r","                       else\r","                           unique_position = true;\r","                       end\r","                       \r","                       if (unique_position == true)\r","                           % Add particle position to known positions\r","                           particles = [particles; [p_dx, p_dy]];\r","                           \r","                           [dx, dy] = simulate_particle_error(options.particle_size * scale_particle, ...\r","                               p_dx, p_dy, ml.wd.xw, ml.wd.yw);\r","                                                      \r","                           % Assumption: All layers are equally affected\r","                           for l = 1:ml.nlayer\r","                               ml.layer(l).wr(wafers(w)).dx = ml.layer(l).wr(wafers(w)).dx + dx;\r","                               ml.layer(l).wr(wafers(w)).dy = ml.layer(l).wr(wafers(w)).dy + dy;\r","                           end\r","                       \r","                       end\r","                   end\r","               end\r","           end\r","       end\r","       \r","   \r","   end\r","end \r","\r","% end of main\r","\r","\r","%% ================ SUBFUNCTIONS BELOW ====================================\r","\r","function [mlo] = add_dirt(mli,spots_definition)\r","   % The impact of particle contamination on overlay is estimated by adding\r","   % particle-shaped bumps to an empty height map and adding the gradient\r","   % of the resulting height map to input overlay data. \r","   % \r","   % wm_filthyfy uses an analytical expression for the bump shape caused by\r","   % a particle between burl and wafer. It also uses 2 system dependent parameters: \r","   % the standard rigidity of a 300mm wafer of 775 um thickness and clamping pressure\r","   % corresponding to NXE electrostatic clamps at 3.2kV.\r","   \r"," \r","   % load empty wm struct\r","   nwafers = length(spots_definition); \r","   wm = bmmo_wm_dummy(nwafers);\r","       \r","    % add spots to height map\r","   wmo = wm_filthyfy(wm,spots_definition);\r","   \r","   % convert to overlay\r","   dirrrrty = bmmo_wm2ovl(wmo,mli);\r","   \r","   % add to input\r","   mlo = ovl_sub(mli,dirrrrty);\r","   \r","end\r","\r","function [dx, dy] = simulate_particle_error(par_size, par_x, par_y, mark_x, mark_y)\r","   % Assumptions:\r","   % - Particle has a perfect spherically shape\r","   % - Stretch of wafer is uniform at any deformed position\r","   % - Stretched surface is circular (as seen from above the wafer), i.e.:\r","   %     _______  __ outer ring (negative/inward mag)\r","   %    /  ___  \\  __ inner ring (positive/outward mag)\r","   %   /  /   \\  \\\r","   %   | |  p  | |  - p(article)\r","   %   \\  \\___/  /\r","   %    \\_______/\r","   %\r","   % - Two rings are defined in the stretched surface:\r","   %   o Inner ring: radius = 500 * radius particle, outward magnification\r","   %   o Outer ring: radius = 1000 * radius particle, inward magnification\r","   % - I.e., stretched surface has a radius equal to 100 * size of particle:\r","   %              |-------1000------|  stretch\r","   %                      |1|    particle (p)\r","   %                  ___________\r","   % ___ wafer ______/     p     \\____________\r","   %\r","   % - The maximum derivative the wafer bends is 5 degrees\r","   %\r","   \r","   % Influence radius and maximum derivative between inner and outer ring\r","   r_infl = 1000 * par_size;\r","   half_r_infl = r_infl / 2;\r","   max_derivative = 0.2; % degrees\r","   \r","   % Describe wafer (bending) shape in terms of a circular function with\r","   % radius r_waf.\r","   r_waf = (r_infl / 2) / sind(max_derivative);\r","   \r","   % Distance between mark and particle\r","   dis_x = par_x - mark_x;\r","   dis_y = par_y - mark_y;\r","   distance = sqrt( dis_x.^2 + dis_y.^2 );\r","   \r","   % marks outside stretch range of particle handled by default vector\r","   % intialization\r","   dx = zeros(size(mark_x));\r","   dy = zeros(size(mark_y));\r","\r","   % Handle marks between inner and outer rings\r","   idx_between_rings = (distance >= half_r_infl) & (distance < r_infl);\r","\r","   rel_distance_between = (r_infl - distance(idx_between_rings)) / half_r_infl;\r","   dxy_between = (rel_distance_between * half_r_infl) - (r_waf * sind( max_derivative * rel_distance_between));\r","   \r","   [dx(idx_between_rings), dy(idx_between_rings)] = sub_get_particle_error_dx_dy(dxy_between, ...\r","       idx_between_rings, dis_x, dis_y, distance);\r","    \r","   % Handle msrks inside inner ring \r","   idx_inside_inner_ring = distance < half_r_infl;\r","    \r","   rel_distance_inner = distance(idx_inside_inner_ring) / half_r_infl;\r","   dxy_inner = r_waf * sind(max_derivative * rel_distance_inner) - distance(idx_inside_inner_ring);\r","\r","   [dx(idx_inside_inner_ring), dy(idx_inside_inner_ring)] = sub_get_particle_error_dx_dy(dxy_inner, ...\r","    idx_inside_inner_ring, dis_x, dis_y, distance);\r","   \r","end\r","\r","function [dx, dy] = sub_get_particle_error_dx_dy(dxy, idx, dis_x, dis_y, distance)\r","\r","dx = -dxy .* (dis_x(idx) ./ distance(idx));\r","dy = -dxy .* (dis_y(idx) ./ distance(idx));\r","end\r","\r","\r",""],"CoverageData":{"CoveredLineNumbers":[30,31,32,33,34,35,36,37,38,40,42,44,47,50,51,52,55,56,58,59,60,65,67,68,69,76,77,79,83,86,87,89,90,98,100,101,102,112,113,115,117,119,121,122,125,130,131,132,133,134,137,139,142,143,145,146,149,154,159,160,161,162,165,166,167,176,177,179,180,182,186,187,189,190,193,194,196,197,200,205,206,209,211,213,214,217,218,219,249,250,253,256,259,288,289,290,294,297,298,299,303,304,307,309,310,312,313,316,318,319,321,322,328,329],"UnhitLineNumbers":[80,81,82,126,201,202],"HitCount":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,0,4,0,4,0,4,0,0,4,0,0,4,4,4,0,0,4,4,0,4,4,4,0,0,0,0,4,0,1,1,1,0,0,0,0,0,0,1,1,0,6,0,0,0,6,0,0,6,6,0,6,6,0,0,0,0,0,0,0,4,0,1,1,1,0,0,0,0,0,0,0,0,0,1,6,0,6,0,60,0,60,0,60,60,0,0,60,0,0,0,0,60,54,54,6,6,0,0,60,0,60,0,0,60,60,0,60,60,0,0,60,0,0,0,0,6,0,0,0,0,4,2,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,1,6,0,6,12,0,12,0,0,0,12,12,0,12,12,0,0,12,6,0,6,6,0,0,6,0,0,0,0,6,6,0,0,12,0,12,0,12,12,0,0,12,12,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,12,12,0,0,0,12,0,0,12,12,12,0,0,0,12,12,0,0,12,0,12,12,0,12,12,0,0,12,0,12,12,0,12,12,0,0,0,0,0,24,24,0,0,0,0]}}