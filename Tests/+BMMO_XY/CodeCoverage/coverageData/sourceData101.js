var sourceData101 = {"FileContents":["function [oDx, oDy] = bmmo_gauss_interp2(ingx, ingy, invalx, invaly, ogx, ogy, grid_size) \r","% function [oDx, oDy] = bmmo_gauss_interp2(ingx, ingy, invalx, invaly, ogx, ogy, grid_size) \r","%\r","% Weighted 2d interpolation using a gaussian function over a square grid\r","% of the given size. The weight for query mark is determined by its distance to \r","% the sample grid, and then calculated by a gaussian function with zero mean and \r","% 3sigma = grid_size. The weights are then normalized.\r","%\r","% Input:  \r","%   ingx:           Sample meshgrid x (m*n double)\r","%   ingy:           Sample meshgrid y (m*n double)\r","%   invalx:         Input values for dx (m*n double) - a function of ingx, ingy\r","%   invaly:         Input values for dy (m*n double) - a function of ingx, ingy\r","%   ogx:            Query meshgrid x (p*q double)\r","%   ogy:            Query meshgrid y (p*q double)\r","%   grid_size:      Side length of square interpolation grid (double)\r","% \r","% Output:\r","%   oDx:            Output interpolated values for dx (p*q double)\r","%   oDy:            Output interpolated values for dy (p*q double)\r","\r","DELTA = 2 * eps; % help correct for rounding errors;\r","\r","% remove NaN values \r","ivx = invalx(:);\r","ivy = invaly(:);\r","idnan = isnan(ivx) | isnan(ivy);\r","ivx(idnan) = [];\r","ivy(idnan) = [];\r","\r","% generate vectors from the input mesh\r","ix = ingx(:); ix(idnan) = [];\r","iy = ingy(:); iy(idnan) = [];\r","ox = ogx(:);\r","oy = ogy(:);\r","\r","oDx = zeros(size(ogx));\r","oDy = oDx;\r","\r","% process output marks in chunks, so that we don't allocate matrices\r","% that are too large\r","current_index = 1;\r","num_points = length(ox); % since they're generated from a meshgrid, length(ox) == length(oy)\r","\r","% set the chunk size we want to interpolate\r","CHUNKSIZE = 30; % experimentation suggests this value is around optimal for this algorithm\r","% (at least for the example input)\r","\r","while current_index < num_points\r","\r","    if (current_index + CHUNKSIZE) < num_points\r","        end_point = current_index + CHUNKSIZE;\r","    else\r","        end_point = num_points;\r","    end\r","\r","    oxchunk = ox(current_index:end_point);\r","    oychunk = oy(current_index:end_point);\r","\r","    % generate (large) i * o matrices\r","    % (output marks in columns)    \r","    % and get the difference between the two matrices\r","    % these are the only inputs we need\r","    [oi, iox] = meshgrid(oxchunk, ix);  \r","    iox = iox - oi;\r","    [oi, ioy] = meshgrid(oychunk, iy);    \r","    ioy = ioy - oi;\r","\r","    % get the grid radius\r","    r = grid_size / 2;\r","    r = r + DELTA; % allow for rounding errors in the input\r","\r","    % get the valid points for interpolation\r","    idvalid = sparse(iox > -r  & iox < r ) & sparse(ioy > -r & ioy < r);\r","\r","    % get the distance and gaussian coefficients\r","    % to save processing time, just do this for valid points\r","    distance = sqrt(iox(idvalid).^2 + ioy(idvalid).^2);\r","    coeff = sub_gaussmf(distance, [grid_size/3 0]);\r","\r","\r","    % remap the coefficients to an i * o matrix\r","    % (coefficients for each output mark are in columns)\r","    normcoeffs = sparse(zeros(length(ivx), length(oxchunk)));\r","    normcoeffs(idvalid) = coeff;\r","\r","    % get the vector of sums of each coefficient\r","    % (sum over the columns)\r","    coeffsum = sum(normcoeffs);\r","\r","    % tile so we can do vectorized division\r","    coeffsum = repmat(coeffsum, length(ix), 1);\r","\r","    % normalize the coefficients, ignoring zero values \r","    % (suppresses DBZ warnings and improves performance)\r","    idvalid = normcoeffs > 0;\r","    normcoeffs(idvalid) = normcoeffs(idvalid) ./ coeffsum(idvalid);\r","\r","    % get the output vectors    \r","    iv = repmat(ivx, 1, length(oxchunk));\r","    oDx_chunk = sum(iv .* normcoeffs);\r","    iv = repmat(ivy, 1, length(oychunk));\r","    oDy_chunk = sum(iv .* normcoeffs);\r","\r","    oDx(current_index:end_point) = oDx_chunk;\r","    oDy(current_index:end_point) = oDy_chunk;\r","    current_index = end_point + 1;\r","\r","end\r","\r","oDx = full(oDx);\r","oDy = full(oDy);\r","    \r","  \r","\r","function y = sub_gaussmf(x, params)\r","%GAUSSMF Gaussian curve membership function.\r","%   GAUSSMF(X, PARAMS) returns a matrix which is the Gaussian\r","%   membership function evaluated at X. PARAMS is a 2-element vector\r","%   that determines the shape and position of this membership function.\r","%   Specifically, the formula for this membership function is:\r","%\r","%   GAUSSMF(X, [SIGMA, C]) = EXP(-(X - C).^2/(2*SIGMA^2));\r","%   \r","%   For example:\r","%\r","%       x = (0:0.1:10)';\r","%       y1 = gaussmf(x, [0.5 5]);\r","%       y2 = gaussmf(x, [1 5]);\r","%       y3 = gaussmf(x, [2 5]);\r","%       y4 = gaussmf(x, [3 5]);\r","%       subplot(211); plot(x, [y1 y2 y3 y4]);\r","%       y1 = gaussmf(x, [1 2]);\r","%       y2 = gaussmf(x, [1 4]);\r","%       y3 = gaussmf(x, [1 6]);\r","%       y4 = gaussmf(x, [1 8]);\r","%       subplot(212); plot(x, [y1 y2 y3 y4]);\r","%       set(gcf, 'name', 'gaussmf', 'numbertitle', 'off');\r","%\r","%   See also DSIGMF,EVALMF, GAUSS2MF, GBELLMF, MF2MF, PIMF, PSIGMF, SIGMF,\r","%   SMF, TRAPMF, TRIMF, ZMF.\r","\r","%   Roger Jang, 6-29-93, 10-5-93.\r","%   Copyright 1994-2002 The MathWorks, Inc. \r","%   $Revision: 1.19 $  $Date: 2002/04/14 22:21:52 $\r","\r","if nargin ~= 2\r","    error_r12('Two arguments are required by the Gaussian MF.');\r","elseif length(params) < 2\r","    error_r12('The Gaussian MF needs at least two parameters.');\r","elseif params(1) == 0,\r","    error_r12('The Gaussian MF needs a non-zero sigma.');\r","end\r","\r","sigma = params(1); c = params(2);\r","y = exp(-(x - c).^2/(2*sigma^2));"],"CoverageData":{"CoveredLineNumbers":[22,25,26,27,28,29,32,33,34,35,37,38,42,43,46,49,51,53,54,57,58,64,65,66,67,70,71,74,78,79,84,85,89,92,96,97,100,101,102,103,105,106,107,111,112,147,149,151,155,156],"UnhitLineNumbers":[52,148,150,152],"HitCount":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,0,10,10,10,10,10,0,0,10,10,10,10,0,10,10,0,0,0,10,10,0,0,10,0,0,10,0,10,0,10,10,0,0,10,10,0,0,0,0,0,10,10,10,10,0,0,10,10,0,0,10,0,0,0,10,10,0,0,0,0,10,10,0,0,0,10,0,0,10,0,0,0,10,10,0,0,10,10,10,10,0,10,10,10,0,0,0,10,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,10,0,10,0,0,0,10,10]}}