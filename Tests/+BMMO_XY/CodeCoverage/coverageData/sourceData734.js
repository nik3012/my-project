var sourceData734 = {"FileContents":["function [isSame, cnt_OK, cnt_NOK] = bmmo_cmp_struct_verbose(strct1, strct2, precision, fid, layer_no, parent_name)\r","% function [isSame, cnt_OK, cnt_NOK] = bmmo_cmp_struct_verbose(strct1, strct2, precision, fid, layer_no, parent_name)\r","% Compare all double/single/logical/NaN/empty-valued members of two\r","% structs. Intended to compare test results from a dd-file. Both struct\r","% members and cells are recursively evaluated. For vectors and matrices,\r","% the maximum absolute value is tested. Fields missing in strct1 or\r","% strct2 also reported as error.\r","%\r","% Usage\r","%   bmmo_cmp_struct(strct1, strct2);\r","%   bmmo_cmp_struct(strct1, strct2, fid);\r","%   [isSame] = bmmo_cmp_struct(strct1, strct2, fid);\r","%   [isSame] = bmmo_cmp_struct(strct1, strct2, fid, layer_no, paren_name);\r","%\r","% Inputs\r","%   strct1     first struct\r","%   strct2     second structv\r","%   fid        file identifier (defaults to 1, std out)\r","%   layer_no   internal use\r","%   paren_name internal use\r","%\r","% Output\r","%   isSame     logical (all double-valued members identical?\r","% Author     Martin Hammer (MHcu)\r","% Created    2014-01-08\r","%\r","% History\r","%   2015-08-24  SBPR Adapted from cmp_struct\r","error(nargchk(2,6,nargin));\r","if (nargin < 3),  precision = 5e-11; end\r","if (nargin < 4),  fid = 1;  end % write to standard out\r","if (nargin < 5),  layer_no = 0;  end\r","if (nargin < 6),  parent_name = '';  end\r","assert(layer_no < 20, 'Structures of more than 20 levels are not supported');\r","\r","isSame    = true(2,1);\r","varname   = inputname(1);\r","\r","if layer_no==0\r","    update_cnt([],true);  % reset counter\r","end\r","% if ~(layer_no==0)       % if not first call\r","%     curr_name = sprintf('%s.%s', parent_name, varname(1:end-2)); % use full struct/cell name\r","% elseif \r","% else\r","%     update_cnt([],true);  % reset counter\r","%     curr_name = varname; % top-struct/cell\r","% end\r","switch class(strct1)\r","  case 'struct'%if isstruct(strct1) % if input is a struct\r","    if ~(layer_no==0)\r","        struct_name = sprintf('%s.%s', parent_name, varname(1:end-2)); % use full struct/cell name\r","    else\r","        struct_name = varname; % top-level struct\r","    end\r","\r","    \r","    dims1 = numel(strct1);\r","    dims2 = numel(strct2);\r","    nStruct = min(dims1,dims2);\r","    \r","    for iStruct = 1:nStruct % for all structs\r","        if (nStruct>1), % add iterator (index) in struct name\r","            curr_name = sprintf('%s(%d)', struct_name, iStruct);\r","        else\r","            curr_name = struct_name;\r","        end\r","\r","        field_cell1 = fieldnames(strct1); % list of field names (strct1)\r","        if isstruct(strct2)\r","            field_cell2 = fieldnames(strct2); % list of field names (strct2)\r","        else\r","            field_cell2 = {};\r","        end\r","\r","        % determine common fields\r","        [~, ind1_com, ind2_com] = intersect(field_cell1, field_cell2);\r","        nFieldsCom = numel(ind1_com);\r","        for ii = 1:nFieldsCom % for all fields\r","            eval(sprintf('   %s_1 = strct1(%d).%s;   ', field_cell1{ind1_com(ii)}, iStruct, field_cell1{ind1_com(ii)})); % copy struct member to local workspace\r","            eval(sprintf('   %s_2 = strct2(%d).%s;   ', field_cell2{ind2_com(ii)}, iStruct, field_cell2{ind2_com(ii)}));\r","            eval(sprintf('   isSame(2) = isSame(2) & bmmo_cmp_struct_verbose(%s_1, %s_2, %d, %d, %d, ''%s'');   ', field_cell1{ind1_com(ii)}, field_cell1{ind1_com(ii)}, precision, fid, layer_no+1, curr_name)); % recursion on struct members (called member_1 and member_2)\r","        end\r","\r","        % determine unique fields in strct1\r","        nFields1 = numel(field_cell1);\r","        if isempty(ind1_com),  ind1_com = nFields1+1;  end % if strct2 is not struct, all fields are missing (no coinciding elements forced by this line)\r","        ind1_unq = find( all(bsxfun(@ne, 1:nFields1, ind1_com),1) );\r","        for ii = 1:(nFields1-nFieldsCom)\r","            fprintf(fid, '%3s : ( %-7s ) ( %-18s )  %s.%s\\n', 'NOK', '', 'field missing -->', curr_name, field_cell1{ind1_unq(ii)});\r","            isSame(2) = false;\r","            update_cnt(isSame(2));\r","        end\r","\r","        % determine unique fields in strct2\r","        nFields2 = numel(field_cell2);\r","        ind2_unq = find( all(bsxfun(@ne, 1:nFields2, ind2_com),1) );\r","        for ii = 1:(nFields2-nFieldsCom)\r","            fprintf(fid, '%3s : ( %-7s ) ( %-18s )  %s.%s\\n', 'NOK', '', '<-- field missing', curr_name, field_cell2{ind2_unq(ii)});\r","            isSame(2) = false;\r","            update_cnt(isSame(2));\r","        end\r","    end % iStruct\r","    \r","    if (dims1 > nStruct) % indices in strct1, but not in strct2\r","        isSame(2) = false; % to force fct output false\r","        for iStruct = nStruct+1:dims1\r","            curr_name = sprintf('%s(%d)', struct_name, iStruct);\r","            fprintf(fid, '%3s : ( %-7s ) ( %-18s )  %s\\n', 'NOK', '', 'struct missing -->', curr_name);\r","            update_cnt(isSame(2));\r","        end\r","    end\r","    \r","    if (dims2 > nStruct) % indices in strct2, but not in strct1\r","        isSame(2) = false; % to force fct output false\r","        for iStruct = nStruct+1:dims2\r","            curr_name = sprintf('%s(%d)', struct_name, iStruct);\r","            fprintf(fid, '%3s : ( %-7s ) ( %-18s )  %s\\n', 'NOK', '', '<-- struct missing', curr_name);\r","            update_cnt(isSame(2));\r","        end\r","    end\r","\r","\r","  case 'cell' % if input is a cell\r","    assert(all([ndims(strct1) ndims(strct2)]<3), 'cells of more than three dimensions not supported.');\r","    dims1 = size(strct1);\r","    dims2 = size(strct2);\r","    dims  = min(dims1, dims2);\r","    iter = 1;\r","    for iCellColumn = 1:dims(2) % for all cell volumns\r","        for iCellRow = 1:dims(1) % for all cell rows\r","            curr_name = sprintf('%s.%s{%d,%d}', parent_name, varname(1:end-2), iCellRow, iCellColumn);\r","            varclass = 'cell';\r","            assert(isa(strct2, varclass), sprintf('Type mismatch: %s.%s is not a cell', parent_name, varname(1:end-2)));\r","            eval(sprintf('   %s_1 = strct1{%d,%d};   ', varclass, iCellRow, iCellColumn)); % copy cell content to workspace\r","            eval(sprintf('   %s_2 = strct2{%d,%d};   ', varclass, iCellRow, iCellColumn));\r","            eval(sprintf('   isSame(2) = isSame(2) & bmmo_cmp_struct_verbose(%s_1, %s_2, %d, %d, %d, ''%s'');   ', varclass, varclass, precision, fid, layer_no+1, curr_name)); % recursion on cell contents\r","            iter = iter + 1;\r","        end\r","    end\r","\r","    % linear index of all entries\r","    ind1 = bsxfun(@plus, (1:dims1(1))', (0:dims1(2)-1)*dims1(1));\r","    ind2 = bsxfun(@plus, (1:dims2(1))', (0:dims2(2)-1)*dims2(1));\r","    ind  = bsxfun(@plus, (1:dims(1))',  (0:dims(2)-1)*dims(1));\r","\r","    % determine indices which does not exist in dims (opposite of intersect)\r","    mask1 = true(size(ind1));\r","    mask1(ind) = false;\r","    mask2 = true(size(ind2));\r","    mask2(ind) = false;\r","\r","    if any(mask1(:)) % indices in strct1, but not in strct2\r","        isSame(2) = false; % to force fct output false\r","        for kk = ind1(mask1)'\r","            [iCellRow, iCellColumn] = ind2sub(kk, dims1);\r","            curr_name = sprintf('%s.%s{%d,%d}', parent_name, varname(1:end-2), iCellRow, iCellColumn);\r","            fprintf(fid, '%3s : ( %-7s ) ( %-18s )  %s\\n', 'NOK', '', 'cell missing -->', curr_name);\r","            update_cnt(isSame(2));\r","        end\r","    end\r","    \r","    if any(mask2(:)) % indices in strct2, but not in strct1\r","        isSame(2) = false; % to force fct output false\r","        for kk = ind2(mask2)'\r","            [iCellRow, iCellColumn] = ind2sub(kk, dims2);\r","            curr_name = sprintf('%s.%s{%d,%d}', parent_name, varname(1:end-2), iCellRow, iCellColumn);\r","            fprintf(fid, '%3s : ( %-7s ) ( %-18s )  %s\\n', 'NOK', '', '<-- cell missing', curr_name);\r","            update_cnt(isSame(2));\r","        end\r","    end\r","\r","  otherwise % input not a struct or cell\r","    if strcmp(varname(1:end-2), 'cell')\r","        curr_name = parent_name; % just add {} for cells\r","    else\r","        curr_name = sprintf('%s.%s', parent_name, varname(1:end-2)); % use full struct name\r","    end\r","    isSame_loc = cmp_data(strct1, strct2, precision, curr_name, fid); % compare data and write to fid (local buffer to prevent typecast to logical)\r","    isSame(2) = isSame_loc;\r","    if islogical(isSame_loc) % if output was not -1, then logical and consequently update counter.\r","        update_cnt(isSame(2));\r","    else\r","        % output is -1, indicating no comparison took please (do not update counter).\r","    end\r","end\r","\r","% combine results\r","isSame = all(isSame);\r","if (layer_no == 0) % last entry (top level), then print results\r","    [cnt_NOK, cnt_OK] = update_cnt(isSame, false, ~layer_no, fid);\r","end\r","\r","\r","\r","\r","\r","\r","\r","function [isSame] = cmp_data(A, B, prec, varname, fid)\r","% Compare two double-valued scalars, vectors, or matrices, A and B,\r","% according precision PREC, with variable name VARNAME and write to file\r","% identifier FID.\r","%\r","%\r","% Author     Martin Hammer (MHcu)\r","% Created    2014-01-08\r","%\r","% History\r","%   2014-01-08 Creation\r","%\r","% Copyright (C) ASML Holding N.V., 2014\r","% ASML Confidential\r","\r","% handle double/single and logicals differently\r","str = {'NOK', 'OK'};\r","\r","if xor(isempty(A),isempty(B)) % empty field present in either A or B\r","    isSame = false;\r","    if isempty(A)\r","        fprintf(fid, '%3s : ( %-7s ) ( %-18s )  %s\\n', 'NOK', '', '<-- empty field', varname);\r","    else\r","        fprintf(fid, '%3s : ( %-7s ) ( %-18s )  %s\\n', 'NOK', '', 'empty field -->', varname);\r","    end\r","    return % print already done\r","elseif isempty(A)&&isempty(B)\r","    isSame = true;    \r","    fprintf(fid, '%3s : ( %-7s ) ( %-18s )  %s\\n', 'OK', '', 'both empty fields', varname);\r","    return\r","elseif ischar(A)&&ischar(B) % compare strings\r","    isSame = strcmp(A,'*')||strcmp(B,'*')||strcmp(A, B);\r","    if strcmp(A,'*')\r","        strA = '*';\r","    else\r","        strA = sprintf('%2d chars',numel(A));\r","    end\r","    if strcmp(B,'*')\r","        strB = '*';\r","    else\r","        strB = sprintf('%2d chars',numel(B));\r","    end\r","    fprintf(fid, '%3s : ( %-7s ) ( %s; %s )  %s\\n', str{isSame+1}, '', strA, strB, varname);\r","    return\r","elseif numel(A)~=numel(B) % variables not of same size\r","    isSame = false;\r","    fprintf(fid, '%3s : ( %-7s ) ( %-18s )  %s\\n', 'NOK', '', 'diff. size', varname);\r","    return; % print already done\r","elseif all([sum(isnan(A(:))) sum(isnan(B(:)))]==numel(A)) % variables of same size and all NaNs\r","    isSame = true;\r","    fprintf(fid, '%3s : ( %-7s ) (%-9s; %-9s)  %s\\n', 'OK', 'same', 'all NaNs', 'all NaNs', varname);\r","    return % print already done\r","elseif (isa(A,'double')&&isa(B,'double')) || (isa(A,'single')&&isa(B,'single')) % double- or single-precision\r","    if any(xor(isnan(A(:)),isnan(B(:)))) % if either is NaN, but other not\r","        isSame = false;\r","        fprintf(fid, '%3s : ( %-7s ) ( %-18s )  %s\\n', 'NOK', 'NaN', '', varname);\r","        return\r","    else\r","        [diffAB,ind] = max( abs(A(:)-B(:)) ); % max of all dims (max ignores NaNs)\r","        isSame = diffAB < prec;\r","        diffAB = diffAB*sign(A(ind)-B(ind));\r","    end\r","elseif (isa(A,'logical')&&isa(B,'logical')) % binary data\r","    diffAB = all(~xor(A(:),B(:))); % all entries identical\r","    isSame = diffAB;\r","else\r","    isSame = -1; % evaluates to true, but allows separate handling in main\r","    fprintf(fid, '%3s : ( %-7s ) ( %-18s )  %s\\n', '--', '', 'not compared', varname);\r","    return % other types not compared\r","end\r","\r","if numel(A)>1 % is matrix\r","    str_dims = sprintf('%dx', size(A)); % string of matrix dimensions\r","    if ~issparse(A)\r","        fprintf(fid, '%3s : (%+8.2e) ( %-18s )  %s\\n', str{isSame+1}, diffAB, str_dims(1:end-1), varname);\r","    else\r","        fprintf(fid, '%3s : (SPARSE) ( %-18s )  %s\\n', str{isSame+1},  str_dims(1:end-1), varname);\r","    end\r","else % is scalar\r","    fprintf(fid, '%3s : (%+8.2e) (%+8.2e; %+8.2e)  %s\\n', str{isSame+1}, diffAB, A, B, varname);\r","end\r","    \r","\r","\r","\r","\r","\r","\r","\r","function [cnt_NOK, cnt_OK] = update_cnt(isSame, reset, print, fid)\r","% Author     Martin Hammer (MHcu)\r","% Created    2014-01-24\r","%\r","% History\r","%   2014-01-24 Creation\r","%\r","% Copyright (C) ASML Holding N.V., 2014\r","% ASML Confidential\r","\r","narginchk(1,4);\r","if nargin < 3,  print = false;  end\r","if nargin < 2,  reset = false;  end\r","assert(islogical(reset)&&islogical(print), 'Input parameters RESET and PRINT should be logicals.');\r","global cnt\r","% persistent cnt % [NOK OK]\r","if isempty(cnt)||reset,\r","    cnt = zeros(2,1);\r","    return % update_cnt()\r","end % reset counter if first instance\r","\r","if print\r","    allOK = (sum(cnt)==cnt(2))&&isSame;\r","    str_out = {'NOK found', 'All OK'};\r","    fprintf(fid, '%s (%d OKs; %d NOKs)\\n', str_out{allOK+1}, cnt(2), cnt(1));\r","else\r","    % update counter\r","    cnt(isSame+1) = cnt(isSame+1) + 1;\r","end\r","\r","if nargout > 0,  cnt_NOK = cnt(1); cnt_OK = cnt(2);  end\r","\r","\r","\r",""],"CoverageData":{"CoveredLineNumbers":[],"UnhitLineNumbers":[29,30,31,32,33,34,36,37,39,40,49,50,51,52,53,54,58,59,60,62,63,64,65,66,69,70,71,72,73,77,78,79,80,81,82,86,87,88,89,90,91,92,96,97,98,99,100,101,105,106,107,108,109,110,114,115,116,117,118,119,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,143,144,145,148,149,150,151,153,154,155,156,157,158,159,163,164,165,166,167,168,169,173,174,175,176,177,179,180,181,182,183,189,190,191,216,218,219,220,221,222,223,225,226,227,228,229,230,231,232,233,234,235,237,238,239,240,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,262,263,264,265,266,267,268,271,272,273,274,275,276,278,279,299,300,301,302,303,305,306,307,310,311,312,313,314,316,319],"HitCount":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}}