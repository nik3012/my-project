var sourceData189 = {"FileContents":["function bmmo_validate_input(input_struct)\r","% function bmmo_validate_input(input_struct)\r","%\r","% Throws an error if the input (data) structure is not as defined in the\r","% functional EDS\r","%\r","% Input:\r","% input_struct: Input structure as generated by bmmo_read_lcp_zip,\r","%               containing YieldStar measurements, report data from TwinScan and\r","%               and previous correction retrieved from TwinScan\r","%\r","% For definition of interface\r","% See D000323756 EDS\r","\r","ml = input_struct;\r","\r","% Define the expected fieldnames\r","fs = bmmo_expected_fields;\r","\r","%% 1. Check root structure for fieldnames\r","found_ml_fieldnames = sub_get_sorted_fieldnames(ml);\r","\r","% make sure that at least the fields in the EDS are present\r","sub_assert_subset(fs.expected_ml_fieldnames, found_ml_fieldnames,  'Fieldnames of ml struct are not as defined in EDS');\r","\r","%% 2. Basic consistency check on layout\r","found_wd_fieldnames = sub_get_sorted_fieldnames(ml.wd);\r","sub_assert_equal(found_wd_fieldnames, fs.expected_wd_fieldnames, 'Fieldnames of ml.wd are not as defined in EDS');\r","\r","nmarks  = length(ml.wd.xw);\r","sub_assert_equal(nmarks, ml.nmark * ml.nfield, 'Inconsistent definition of ml.nmark, ml.nfield');\r","sub_assert_equal(nmarks, length(ml.wd.xw), 'Inconsistent length for ml.wd.xw');\r","sub_assert_equal(nmarks, length(ml.wd.yw), 'Inconsistent length for ml.wd.yw');\r","sub_assert_equal(nmarks, length(ml.wd.xc), 'Inconsistent length for ml.wd.xc');\r","sub_assert_equal(nmarks, length(ml.wd.yc), 'Inconsistent length for ml.wd.yc');\r","sub_assert_equal(nmarks, length(ml.wd.xf), 'Inconsistent length for ml.wd.xf');\r","sub_assert_equal(nmarks, length(ml.wd.yf), 'Inconsistent length for ml.wd.yf');\r","\r","% Check that there are no duplicate mark coordinates\r","x_y = ml.wd.xw + 1i * ml.wd.yw;\r","sub_assert_equal(length(unique(x_y)), nmarks, 'Duplicate mark coordinates found in input');\r","\r","%% 3. Basic consistency check on wafer maps\r","sub_assert_equal(ml.nlayer, 1, 'Input ml struct must have exactly one layer');\r","sub_assert_equal(length(ml.layer), ml.nlayer, 'Inconsistent definition of ml.layer');\r","\r","found_fieldnames = sub_get_sorted_fieldnames(ml.layer);\r","sub_assert_equal(found_fieldnames, fs.expected_layer_fieldnames, 'Fieldnames of ml.layer are not as defined in EDS');\r","\r","sub_assert_equal(length(ml.layer.wr), ml.nwafer, 'Inconsistent definition of ml.layer.wr');\r","\r","for iw = 1:ml.nwafer\r","    sub_assert_equal(length(ml.layer.wr(iw).dx), nmarks, 'Inconsistent definition of ml.layer.wr.dx');\r","    sub_assert_equal(length(ml.layer.wr(iw).dy), nmarks, 'Inconsistent definition of ml.layer.wr.dy');\r","end\r","\r","%% 4. Check info fieldnames\r","found_fieldnames = sub_get_sorted_fieldnames(ml.info);\r","sub_assert_subset(fs.expected_info_fieldnames, found_fieldnames, 'Fieldnames of ml.info are not as defined in EDS');\r","\r","%% 4.1 Check report data\r","found_fieldnames = sub_get_sorted_fieldnames(ml.info.report_data);\r","\r","sub_assert_subset(fs.expected_report_data_fieldnames, found_fieldnames, 'Fieldnames of ml.info.report_data are not as defined in EDS');\r","\r","%sub_assert( length(ml.info.report_data.Scan_direction) >= ml.nfield, 'Not enough scan directions defined for the number of fields');\r","\r","sub_assert_equal(length(ml.info.report_data.WH_K_factors.wafer), ml.nwafer, 'Not enough WH K-factors per wafer');\r","\r","% check the first field for K-factors. \r","% K-factors names must be in the correct order.\r","K_factor_names = reshape(fieldnames(ml.info.report_data.WH_K_factors(1).wafer(1).field), 1, []);\r","\r","sub_assert_equal(lower(K_factor_names), lower(fs.expected_parlist), 'WH K-factors not present as defined in EDS');\r","\r","%% 4.2 Check previous correction\r","found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction);\r","sub_assert_subset(found_fieldnames, fs.expected_pc_fieldnames, 'Previous_correction not as defined in EDS');\r","\r","found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.KA);\r","\r","if isfield(ml.info.previous_correction.KA, 'grid_2dc')% For backwards compatiblity\r","    sub_assert_subset(fs.expected_KA_fieldnames, found_fieldnames, 'pc.KA fieldnames not as defined in EDS');\r","    %KA@E\r","    found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.KA.grid_2de(1));\r","    sub_assert_equal(found_fieldnames, fs.expected_ffp_fieldnames, 'pc.KA.grid_2de fieldnames not as defined in EDS');\r","    %KA@M\r","    found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.KA.grid_2dc(1));\r","    sub_assert_equal(found_fieldnames, fs.expected_ffp_fieldnames, 'pc.KA.grid_2dc fieldnames not as defined in EDS');\r","else\r","    %KA@E\r","    sub_assert_subset(fs.expected_KA_E_fieldnames, found_fieldnames, 'pc.KA fieldnames not as defined in EDS');\r","    \r","    found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.KA.grid_2de(1));\r","    sub_assert_equal(found_fieldnames, fs.expected_ffp_fieldnames, 'pc.KA.grid_2de fieldnames not as defined in EDS');\r","end\r","\r","\r","found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.MI);\r","sub_assert_equal(found_fieldnames, fs.expected_MI_fieldnames, 'pc.MI fieldnames not as defined in EDS');\r","\r","found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.MI.wse(1));\r","sub_assert_equal(found_fieldnames, fs.expected_MI_wse_fieldnames, 'pc.MI.wse fieldnames not as defined in EDS');\r","\r","found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.MI.wse(1).x_mirr);\r","sub_assert_equal(found_fieldnames, fs.expected_MI_x_mirr_fieldnames, 'pc.MI.wse.x_mirr fieldnames not as defined in EDS');\r","\r","found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.MI.wse(1).y_mirr);\r","sub_assert_equal(found_fieldnames, fs.expected_MI_y_mirr_fieldnames, 'pc.MI.wse.y_mirr fieldnames not as defined in EDS');\r","\r","found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.ffp);\r","sub_assert_equal(found_fieldnames, fs.expected_ffp_fieldnames, 'pc.ffp fieldnames not as defined in EDS');\r","\r","found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.BAO);\r","sub_assert_equal(found_fieldnames, fs.expected_BAO_fieldnames, 'pc.BAO fieldnames not as defined in EDS');\r","\r","if isfield(ml.info.previous_correction, 'SUSD')\r","    found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.SUSD);\r","    sub_assert_equal(fs.expected_SUSD_fieldnames, found_fieldnames, 'pc.SUSD fieldnames not as defined in EDS');\r","end\r","\r","%% 4.3 Check info.F structure\r","found_fieldnames = sub_get_sorted_fieldnames(ml.info.F);\r","if isfield(ml.info.F, 'image_shift')\r","    sub_assert_equal(found_fieldnames, fs.expected_F_image_shift_fieldnames,'info.F fieldnames not as defined in EDS');\r","else\r","    sub_assert_equal(found_fieldnames, fs.expected_F_fieldnames, 'info.F fieldnames not as defined in EDS');\r","end\r","sub_assert_equal(length(ml.info.F.chuck_id), ml.nwafer, 'Inconsistent definition of info.F.chuck_id');\r","sub_assert_equal(length(ml.info.F.wafer_accepted), ml.nwafer, 'Inconsistent definition of info.F.wafer_accepted');\r","\r","%% 4.4 Check info.M structure\r","found_fieldnames = sub_get_sorted_fieldnames(ml.info.M);\r","sub_assert_equal(found_fieldnames, fs.expected_M_fieldnames, 'info.M fieldnames not as defined in EDS');\r","\r","\r","%% 5. Check expinfo structure\r","found_fieldnames = sub_get_sorted_fieldnames(ml.expinfo);\r","sub_assert_subset(fs.expected_expinfo_fieldnames, found_fieldnames, 'info.expinfo not as defined in EDS');\r","\r","\r","%% End of main function, sub-functions below\r","\r","    %% Fail if a is not a subset of b, uses R13-compatible version of assert\r","    function sub_assert_subset(a, b, msg)\r","        \r","    common = intersect(a, b);\r","    sub_assert_equal(common, a, msg);\r","\r","    %% R13-compatible version of assert_equal\r","    function sub_assert_equal(a, b, msg)\r","\r","    result = isequal(a,b);\r","    sub_assert(result, msg);\r","\r","    %% R13-compatible version of assert\r","    function sub_assert(result, msg)\r","\r","    if ~result\r","        error_r12(['invalid_input ', msg]);\r","    end\r","\r","    %% Return the fieldnames of input_struct, sorted into one row\r","    function fnames = sub_get_sorted_fieldnames(input_struct)\r","\r","    fnames = sort(reshape(fieldnames(input_struct), 1, []));\r","\r",""],"CoverageData":{"CoveredLineNumbers":[15,18,21,24,27,28,30,31,32,33,34,35,36,37,40,41,44,45,47,48,50,52,53,54,58,59,62,64,68,72,74,77,78,80,82,83,85,86,88,89,90,92,94,95,99,100,102,103,105,106,108,109,111,112,114,115,117,118,119,123,124,125,126,127,129,130,133,134,138,139,147,148,153,154,159,160,166],"UnhitLineNumbers":[],"HitCount":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,179,0,0,179,0,0,179,0,0,179,0,0,178,178,0,178,178,177,177,177,177,177,177,0,0,177,177,0,0,176,176,0,176,176,0,176,0,176,906,906,0,0,0,176,176,0,0,176,0,176,0,0,0,176,0,0,0,176,0,176,0,0,176,176,0,176,0,176,171,0,171,171,0,171,171,5,0,5,0,5,5,0,0,0,176,176,0,176,176,0,176,176,0,176,176,0,176,176,0,176,176,0,176,174,174,0,0,0,176,176,3,173,173,0,176,176,0,0,176,176,0,0,0,175,175,0,0,0,0,0,0,0,1058,1058,0,0,0,0,7802,7802,0,0,0,0,7802,4,0,0,0,0,0,3341,0,0]}}