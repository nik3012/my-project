var sourceData432 = {"FileContents":["function [ml, kt_struct] = bmmo_KT_2_ml( path, use_layout, lt, markname, marktype, kt_struct )\r","% function ml = bmmo_KT_2_ml( path, use_layout, ml_tmp, markname, marktype )\r","%\r","% Given a KT_wafers_* file and a markname and marktype, generate an ml structure based on\r","% the given template and x,y shifts\r","%\r","% Input:\r","%   path: full path of KT_wafers_* file\r","%   use_layout: nonzero if lt is an ml structure with an input layout;\r","%       otherwise zero\r","%   lt: if use_layout is > 0, a single-layer, single-wafer ml structure to\r","%       provide the layout; otherwise the number of digits to round the\r","%       input to\r","%   markname: mark name to load from KT_wafers (e.g. 'EXPOSED!')\r","%   marktype: mark type to load from KT_wafers (e.g. 'XPA')\r","%\r","% Output: \r","%   ml: generated ml structure\r","%\r","% 20160331 SBPR Refactored from KT_wo_2_ml\r","\r","if use_layout    \r","    % generate a template output\r","    ml = ovl_create_dummy(lt);\r","\r","    % get the layout marks from the template input\r","    layout_marks = [lt.wd.xw, lt.wd.yw];\r","else\r","    ml = struct;\r","end\r","    \r","if nargin < 6\r","    % load the marks into a matlab structure\r","    kt_struct = dd2mat(0, path);\r","end\r","\r","% kt_struct will be a nwafer * 1 structure array\r","nwafer = length(kt_struct);\r","ml.nwafer = nwafer;\r","\r","\r","for iw = 1:ml.nwafer\r","\r","    % get a nmark * 2 matrix of the marks of interest\r","    index = strcmp({kt_struct(iw).AA_marks.name}, markname) & strcmp({kt_struct(iw).AA_marks.mark_type}, marktype);\r","\r","    if ~any(index)\r","        error(['No marks of name ' markname ' and type ' marktype ' found!']);\r","    end\r","    \r","    aa_marks = [kt_struct(iw).AA_marks(index)];\r","    aa_marks = [aa_marks.position];\r","\r","    xvec = [aa_marks.x];\r","    yvec = [aa_marks.y];\r","\r","    marks = [xvec', yvec'];\r","\r","    if ~use_layout && iw == 1\r","        ml.wd.xw = round(marks(:, 1), lt);\r","        ml.wd.yw = round(marks(:, 2), lt);\r","        ml.wd.xc = ml.wd.xw;\r","        ml.wd.yc = ml.wd.yw;\r","        ml.wd.xf = zeros(size(ml.wd.xw));\r","        ml.wd.yf = ml.wd.xf;\r","        ml.nmark = 1;\r","        ml.nfield = length(ml.wd.xw);\r","        ml.nlayer = 1;\r","        \r","        layout_marks = [ml.wd.xw, ml.wd.yw];\r","    end\r","        \r","     %figure; plot(layout_marks(:,1), layout_marks(:,2), 'bo');\r","     %hold; plot(marks(:,1), marks(:,2), 'rx');\r","    \r","    \r","    % for each point in marks, get the index and distance of the closest point\r","    % in layout_marks\r","    [I, D] = knnsearch(layout_marks, marks, 'k', 1);\r","\r","    % ignore all indices greater than threshold\r","    % TODO: handle marks in shifted fields, etc.\r","    THRESH = 1e-6;\r","    \r","    if any(D >= THRESH)\r","        warning('Not all marks in KT_wafers could be mapped to input layout');\r","    end\r","        \r","    I = I(D < THRESH);\r","    marks = marks(D < THRESH, :);\r","\r","    tmp_out = nan(size(layout_marks));\r","    tmp_out(I, :) = marks - layout_marks(I, :);\r","\r","    ml.layer.wr(iw).dx = tmp_out(:, 1);\r","    ml.layer.wr(iw).dy = tmp_out(:, 2);\r","end\r",""],"CoverageData":{"CoveredLineNumbers":[],"UnhitLineNumbers":[22,24,27,28,29,32,34,38,39,42,45,47,48,51,52,54,55,57,59,60,61,62,63,64,65,66,67,68,70,79,83,85,86,89,90,92,93,95,96],"HitCount":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}}