var sourceData143 = {"FileContents":["function [B,C] = bmmo_interp_nans(A,X,Y, nb, step, max_loop_in)\r","%function [B,C] = bmmo_interp_nans(A,X,Y, nb, step, max_loop_in)\r","%\r","% This function interpolates the values of the NaNs in an input matrix\r","%\r","% Input:\r","%     A: wafer map (2d matrix)\r","%     X: vector of unique values in xw, used to calculate weights\r","%     Y: vector of unique values in yw\r","%\r","% Optional Input:\r","%     nb: optional neighbourhood type for interpolation algorithm\r","%         possible values are as follows:\r","%             'updown': look for neighbours in adjacent horizontal and vertical positions\r","%             'diagonal': same as updown, plus adjacent diagonal positions\r","%               (consumes more memory, slightly slower)\r","%     step: boolean 1 if nans with more non-nan neighbours are to be filled in\r","%           first. Can be faster for input matrices with lots of NaNs.\r","%     max_loop_in: maximum number of loops over which to iterate\r","%\r","%  Output:\r","%     B: interpolated wafer map with Nans replaced by interpolated values\r","%     C: logical map of interpolation marks in B\r","\r","MAX_LOOP = 301; % quit the while loop (with an error) if this number of loop iterations is exceeded\r","MAX_WEIGHT = 1e4; % arbitrary large weight to replace infinity values\r","\r","\r","\r","B = A; %First copy matrix\r","C = isnan(A); %logical index of interpolation marks; initialised to all NaNs\r","\r","if nargin > 3\r","    nb_type = nb;\r","else\r","    nb_type = 'updown';\r","end\r","\r","if nargin > 4\r","    use_step = step;\r","else\r","    use_step = 0;\r","end\r","\r","if nargin > 5\r","    max_loop = max_loop_in;\r","    if max_loop < 1\r","        max_loop = 1;\r","    elseif max_loop > MAX_LOOP\r","        max_loop = MAX_LOOP;\r","    end\r","else\r","    max_loop = MAX_LOOP;\r","end\r","\r","%check if matrix has only zeros and nans; if so, just return a matrix of\r","%zeros\r","if ~any(A(~C))\r","    B = zeros(size(A));\r","else\r","    %Make meshgrid X&Y\r","    [Xi,Yi] = meshgrid(X,Y);\r","    \r","    % ensure X and Y are vertical\r","    X = reshape(X, [], 1);\r","    Y = reshape(Y, [], 1);\r","    \r","    % make some vertical, horizontal weight matrices\r","    [xg_l, yg_u] = meshgrid([nan; X(1:end-1)], [nan; Y(1:end-1)]);\r","    [xg_r, yg_d] = meshgrid([X(2:end); nan], [Y(2:end); nan] );\r","    xg_l = abs(Xi - xg_l);\r","    xg_r = abs(Xi - xg_r);\r","    yg_u = abs(Yi - yg_u);\r","    yg_d = abs(Yi - yg_d);\r","    \r","    % make diagonal weight matrices too, if nb_type is diagonal\r","    if strcmp(nb_type, 'diagonal')\r","        g_lu = 1 ./ sqrt(xg_l .^2 + yg_u .^2);\r","        g_ru = 1 ./ sqrt(xg_r .^2 + yg_u .^2);\r","        g_ld = 1 ./ sqrt(xg_l .^2 + yg_d .^2);\r","        g_rd = 1 ./ sqrt(xg_r .^2 + yg_d .^2);\r","        g_lu(isnan(g_lu)) = 0;\r","        g_ru(isnan(g_ru)) = 0;\r","        g_ld(isnan(g_ld)) = 0;\r","        g_rd(isnan(g_rd)) = 0;\r","        g_lu(isinf(g_lu)) = MAX_WEIGHT;\r","        g_ru(isinf(g_ru)) = MAX_WEIGHT;\r","        g_ld(isinf(g_ld)) = MAX_WEIGHT;\r","        g_rd(isinf(g_rd)) = MAX_WEIGHT;\r","    end\r","    \r","    xg_l = 1 ./ xg_l;\r","    xg_r = 1 ./ xg_r;\r","    yg_u = 1 ./ yg_u;\r","    yg_d = 1 ./ yg_d;\r","    xg_l(isnan(xg_l)) = 0;\r","    xg_r(isnan(xg_r)) = 0;\r","    yg_u(isnan(yg_u)) = 0;\r","    yg_d(isnan(yg_d)) = 0;\r","    xg_l(isinf(xg_l)) = MAX_WEIGHT;\r","    xg_r(isinf(xg_r)) = MAX_WEIGHT;\r","    yg_u(isinf(yg_u)) = MAX_WEIGHT;\r","    yg_d(isinf(yg_d)) = MAX_WEIGHT;\r","    \r","    \r","    % make vertical and horizontal shifted input matrices\r","    Bl =  [zeros(size(B, 1), 1) *nan , B(:, 1:end-1)];\r","    Br =  [B(:, 2:end), zeros(size(B, 1), 1) *nan];\r","    Bu =  [zeros(1, size(B, 2)) *nan ; B(1:end-1, :)];\r","    Bd =  [B(2:end, :) ; zeros(1, size(B, 2)) *nan ];\r","    \r","    % make diagonal shifted input matrices too\r","    % if nb_type is diagonal\r","    if strcmp(nb_type, 'diagonal')\r","        Blu = [zeros(1, size(B, 2)) *nan; Bl(1:end-1, :)];\r","        Bru = [zeros(1, size(B, 2)) *nan ; Br(1:end-1, :)];\r","        Bld =  [Bl(2:end, :) ; zeros(1, size(B,2)) *nan];\r","        Brd =  [Br(2:end, :) ; zeros(1, size(B,2)) *nan];\r","    end\r","    \r","    %This interpolates the nans. It will sweep the wafer several times\r","    %filling in the nans.\r","    loop_iter = 0;\r","    \r","    while any(any(isnan(B)))\r","        \r","        %for each nan point, collect non-nan neighbors\r","        D = sub_count_nans_in_neighbourhood(B, nb_type);\r","        C = isnan(B);\r","        D(~C) = 0;\r","        maxnrnan = max(D(:));\r","        \r","        \r","        % for points-neighbors entry having max non-nan neighbors,\r","        % fill in weighted-average of non-nan neighbors\r","        index = (D == maxnrnan);\r","        \r","        if(any(any(index)))\r","            % sum the weights\r","            weights = [xg_l(index), xg_r(index), yg_u(index), yg_d(index)];\r","            buren = [Bl(index), Br(index), Bu(index), Bd(index)];\r","            if strcmp(nb_type, 'diagonal')\r","                weights = [weights, g_lu(index), g_ru(index), g_ld(index), g_rd(index)];\r","                buren = [buren, Blu(index), Bru(index), Bld(index), Brd(index)];\r","            end\r","            \r","            nanburen = isnan(buren);\r","            valid_rows = ~all(nanburen, 2);\r","            buren(nanburen) = 0;\r","            weights(nanburen) = 0;\r","            \r","            interp_val = zeros(size(valid_rows)) * nan;\r","            sumbw = sum((buren .* weights), 2);\r","            sumw = sum(weights, 2);\r","            interp_val(valid_rows) = sumbw(valid_rows) ./ sumw(valid_rows);\r","            \r","            % set the interpolated values\r","            B(index) = interp_val;\r","            \r","            % rebuild shifted input matrices\r","            Bl =  [zeros(size(B,1), 1) *nan , B(:, 1:end-1)];\r","            Br =  [B(:, 2:end), zeros(size(B,1), 1) * nan];\r","            Bu =  [zeros(1, size(B,2)) *nan ; B(1:end-1, :)];\r","            Bd =  [B(2:end, :) ; zeros(1, size(B,2)) * nan];\r","            if strcmp(nb_type, 'diagonal')\r","                Blu = [zeros(1, size(B,2)) *nan; Bl(1:end-1, :)];\r","                Bru = [zeros(1, size(B,2)) *nan; Br(1:end-1, :)];\r","                Bld =  [Bl(2:end, :) ; zeros(1, size(B,2))*nan];\r","                Brd =  [Br(2:end, :) ; zeros(1, size(B,2))*nan];\r","            end\r","        end\r","    end\r","    \r","    loop_iter = loop_iter + 1;\r","    if(loop_iter >= MAX_LOOP)\r","        error('bmmo_interp_nans: maximum number of loop iterations exceeded');\r","    end\r","end\r","\r","\r","function [D] = sub_count_nans_in_neighbourhood(B, nb)\r","% function [D] = sub_count_nans_in_neighbourhood(B, nb)\r","%\r","% This function counts the number of NaNs in the specified neighbourhood of each\r","% element in Matrix B.\r","%\r","% Input:\r","%    B: A 2d matrix, possibly containing NaNs\r","%\r","% Optional Input:\r","%   nb: A neighbourhood function (string)\r","%       Implemented functions are\r","%        'updown': count nans in horizontally and vertically adjacent\r","%                   positions\r","%        'diagonal': same as above, but also count diagonally adjacent\r","%                   positions\r","%\r","% Output:\r","%   D: Matrix of same size as B, where\r","%        D[i,j] == number of NaNs in the neighbourhood of B[i,j]\r","%\r","% This works by convolving the function isnan(B) with the specified neighbourhood\r","% function.\r","%\r","C = ~isnan(B);\r","\r","if nargin == 2\r","    nb_type = nb;\r","else\r","    nb_type = 'updown';\r","end\r","\r","%nsew neighbourhood\r","switch nb_type\r","    case 'updown'\r","        neighbourhood = [0 1 0; 1 0 1; 0 1 0];\r","    case 'diagonal'\r","        neighbourhood = [1 1 1; 1 0 1; 1 1 1];\r","    otherwise\r","        error(['sub_count_nans_in_neighbourhood: unknown neighbourhood type ' nb]);\r","end\r","\r","D = conv2(double(C), neighbourhood, 'same');\r",""],"CoverageData":{"CoveredLineNumbers":[25,26,30,31,33,34,35,36,39,40,41,42,45,46,47,48,49,50,52,53,58,59,60,62,65,66,69,70,71,72,73,74,77,78,79,80,81,82,83,84,85,86,87,88,89,92,93,94,95,96,97,98,99,100,101,102,103,107,108,109,110,114,115,116,117,118,123,125,128,129,130,131,136,138,140,141,142,143,144,147,148,149,150,152,153,154,155,158,161,162,163,164,165,166,167,168,169,174,175,205,207,208,214,215,216,217,218,223],"UnhitLineNumbers":[176,209,210,219,220],"HitCount":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14916,14916,0,0,0,14916,14916,0,14916,14910,6,6,0,0,14916,14907,9,9,0,0,14916,2,2,1,1,1,0,14914,14914,0,0,0,0,14916,447,14469,0,14469,0,0,14469,14469,0,0,14469,14469,14469,14469,14469,14469,0,0,14469,14456,14456,14456,14456,14456,14456,14456,14456,14456,14456,14456,14456,0,0,14469,14469,14469,14469,14469,14469,14469,14469,14469,14469,14469,14469,0,0,0,14469,14469,14469,14469,0,0,0,14469,14456,14456,14456,14456,0,0,0,0,14469,0,14469,0,0,105201,105201,105201,105201,0,0,0,0,105201,0,105201,0,105201,105201,105201,105061,105061,0,0,105201,105201,105201,105201,0,105201,105201,105201,105201,0,0,105201,0,0,105201,105201,105201,105201,105201,105061,105061,105061,105061,0,0,0,0,14469,14469,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,105201,0,105201,105201,0,0,0,0,0,105201,105201,140,105061,105061,0,0,0,0,105201,0]}}