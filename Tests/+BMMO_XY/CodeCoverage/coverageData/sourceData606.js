var sourceData606 = {"FileContents":["function  [par_mc, extra_data, par, KPI, RES, COR] = bmmo_model_inlineSDM_new(ml_field_chk1, ml_field_chk2, varargin)\r","%% Output\r","%     par_mc.scan\r","%     par_mc.lens\r","%     extra_data.corr.lens \r","%     extra_data.corr.scan \r","%     extra_data.corr.lens_static\r","%     extra_data.input.lens\r","%     extra_data.input.scan\r","%     KPI (1~8) as defined on page 23 in D000347979\r","%     RES (1~3) as defined on page 23 in D000347979\r","\r","%% Input \r","%     ml struct - BMMO input (13x19) averaged fields after removing KA, MI, ..., 10 par BAO \r","%     Note : zernikes in [nm], adjustables in [um]\r","\r","%% Handle options\r","optionsDef.HOC           = 1;\r","optionsDef.lens_type     = '3400';\r","optionsDef.interpolation = 'polyfit4';\r","optionsDef.LFP           = 1;\r","optionsDef.CET_model     = 'sdm3600'; % obsolete\r","optionsDef.filterCoeff   = 1; \r","[options, arguments] = ovl_parse_options(optionsDef, varargin{:}); % do NOT remove {:} because this is needed for Matlab varargin syntax\r","\r","%temporary dirty implementation of SDMModel in input arguments <<<<<<<<<<<<<<<<<<<<<<<<<<\r","if isstruct(arguments{1})\r","    SDMModel = arguments{1};\r","else\r","    SDMModel.filter      = 'spline';\r","    SDMModel.actuation   = '3600D';\r","    SDMModel.poly2spline = 0;\r","    SDMModel.playback    = 0;\r","end\r","\r","\r","% load data using LMtwin toolbox\r","if ~exist('lm_calc_aberrations','file')\r","    if ispc\r","    error('OVL:ovl_model_sdm:lm_twin_not_found',['Cannot find projection toolbox; please add the projection module:\\n' ...\r","        'use module.include(''\\\\\\\\asml.com\\\\eu\\\\shared\\\\nl011032\\\\Projection_tooling\\\\projection_toolbox_p'')\\n' ...\r","        '(if you don''t have access to this share, please request access using\\n' ...\r","        'https://calltemplates.asml.com/cgi-bin/calltemplates.cgi?form_id=50302)']);\r","    else\r","    error('OVL:ovl_model_sdm:lm_twin_not_found',['Cannot find projection toolbox; please add the projection module:\\n' ...\r","        'use module.include(''/shared/nl011032/Projection_tooling/projection_toolbox_p'')\\n' ...\r","        '(if you don''t have access to this share, please request access using\\n' ...\r","        'https://calltemplates.asml.com/cgi-bin/calltemplates.cgi?form_id=50302)']);\r","    end\r","end\r","\r","%% For now, SDM needs data from .info field\r","if ~isfield(ml_field_chk1, 'info') & ~strcmp( optionsDef.lens_type, 'guess')\r","    disp('OVL:ovl_model_sdm:missing_info, the SDM model is most accurate in case the .info field is given, containing relevant lens MCs');\r","    if options.LFP\r","        error('OVL:ovl_model_sdm:missing_LFP', 'LFP usage is requested, but not available. The ''.info'' field is needed in the input tlg');\r","    end\r","end\r","%% load definition : Machine type\r","lensdata = ovl_metro_parse_lens_data(ml_field_chk2, 'lens_type', options.lens_type);\r","\r","%% LFP\r","szd_LFP = zeros(5,13,64); \r","mli = ml_field_chk1;\r","if options.LFP\r","    if isstruct(mli.info.F.LFP_data)\r","    % load LFP and do the decryption, if needed\r","    creation_time=mli.info.F.date;\r","    where_us=findstr(creation_time,'us');\r","    where_space=findstr(creation_time(1:where_us),' ');\r","    creation_time=str2num(creation_time(where_space(end)+1:where_us-1));\r","    for jj=1:5\r","        for ii=1:13\r","            for hh=1:63 \r","                dummylfp = mli.info.F.LFP_data.y(jj).zd(ii,hh+1);\r","                if abs(dummylfp) < 0.000001\r","                    szd_LFP(jj,ii,hh)=1e9*dummylfp; % load only\r","                else                    \r","                    szd_LFP(jj,ii,hh)=1e9/(dummylfp * (creation_time + (jj - 1) * 13 + ii + hh - 3));  % load and decrpt\r","                end\r","            end\r","        end\r","    end\r","    else \r","        szd_LFP(:,:,1:62) = mli.info.F.LFP_data(:,:,2:63)*1e9;\r","    end\r","end\r","%% Initialize outputs\r","ml_res           = [];\r","par_mc           = [];\r","extra_data       = [];\r","\r","ml_field_avg = ovl_combine_linear(ml_field_chk1,0.5, ml_field_chk2, 0.5);\r","%% Scan integrate (13x1) : (dx,dy)\r","% Note that ovl_scan_intagrate+ovl_average_columns=ovl_average_columns\r","% ovl_scan_integrate (13x7/19) = ovl_average_columns (13x1) x 7/19 copies in y\r","ml_dynrep_input_dlm = ovl_scan_integrate(ml_field_avg);  %(13x7/19)\r","ml_dyn_input_dlm = ovl_average_columns(ml_field_avg);  % (13x1)\r","\r","%% Pre-processing for HOC Model \r","tmp = ovl_scan_integrate(ml_field_avg);     % (13x19) : constant interpolation of 13x1 ; copies of ml_dyn_input_dlm in y direction\r","ml_input_HOC(1) = ovl_sub(ml_field_chk1, tmp );      % subtract lens correctables (13x19)\r","ml_input_HOC(2) = ovl_sub(ml_field_chk2, tmp );   \r","\r","%% HOC Model\r","% Removed HOCrespart_z2z3 from output, lensdata from input of Hocmodel. Was\r","% not used anyway.\r","% output intra_par_HOC no longer available, because cet_model does not\r","% provide it.\r","for ichk = 1:2\r","    %[ml_HOC_res(ichk), ml_field_HOC_corr(ichk), intra_par_HOC(ichk)] = HOCModel_new(ml_input_HOC(ichk), SDMModel);\r","    [ml_HOC_res(ichk), ml_field_HOC_corr(ichk), mlHocFad(ichk)] = HOCModel_new(ml_input_HOC(ichk), SDMModel);\r","end\r","%% Z2Z3 originally done in HOC Model\r","% with HOCModel_test01 removed it there and put it here.\r","for ichk = 1:2\r","    ml_HOC_res_dyn = ovl_average_columns(ml_HOC_res(ichk)); \r","    % dx, dy -> Zernikes\r","    xs = spline( ml_HOC_res_dyn.wd.xf', ml_HOC_res_dyn.layer.wr.dx', lensdata.X);\r","    ys = spline( ml_HOC_res_dyn.wd.xf', ml_HOC_res_dyn.layer.wr.dy', lensdata.X);\r","\r","    z2_HOCrespart = xs * lensdata.Generic.Lens.Factors.dZ2_dX * 1e+09; %[nm]\r","    z3_HOCrespart = ys * lensdata.Generic.Lens.Factors.dZ3_dY * 1e+09; %[nm]\r","\r","    HOCrespart_z2z3(ichk).z2 = z2_HOCrespart;\r","    HOCrespart_z2z3(ichk).z3 = z3_HOCrespart;\r","end \r","%% Lens Corrections\r","% No residual of HOC goes to the DLM\r","par_lens(1:13) = zeros(size(lensdata));\r","par_lens(13+1:13*2) = zeros(size(lensdata));\r","par_lens(27) = options.filterCoeff;\r","[Static_corr_Z, ml_field_lens_corr, adj_pob, par] = LensCorrections(ml_dynrep_input_dlm, lensdata, szd_LFP, par_lens);\r","\r","\r","%% Fill other outputs\r","extra_data.corr.lens = ml_field_lens_corr;\r","extra_data.corr.lens_static = Static_corr_Z;\r","extra_data.input.lens= ml_dynrep_input_dlm;  %dx, dy in [m]\r","extra_data.res.lens = ovl_sub(extra_data.input.lens, extra_data.corr.lens);\r","for ichk = 1:2\r","    extra_data.corr.scan(ichk)  = ml_field_HOC_corr(ichk);\r","    extra_data.input.scan(ichk) = ml_input_HOC(ichk);\r","end\r","extra_data.input.chk(1)=ml_field_chk1;\r","extra_data.input.chk(2)=ml_field_chk2;\r","extra_data.input.avg = ml_field_avg;\r","%% Setting par_mc :  adj in [um and urad]\r","\r","%par_mc.scan = intra_par_HOC; % < no longer returned by HOCmodel\r","par_mc.scan = [];             % for compatibility still here.\r","par_mc.lens.Ob_z                                = adj_pob( find( strcmp( cellstr( lensdata.Generic.Manipulator.Name), 'Reticle.Z')));\r","par_mc.lens.Ob_Rx                               = adj_pob( find( strcmp( cellstr( lensdata.Generic.Manipulator.Name), 'Reticle.Rx')));\r","par_mc.lens.Ob_Ry                               = adj_pob( find( strcmp( cellstr( lensdata.Generic.Manipulator.Name), 'Reticle.Ry')));\r","for mirror_idx = [1 2 3 4 6]; \r","   par_mc.lens.(sprintf('Mi%d_x',  mirror_idx)) = adj_pob( find( strcmp( cellstr( lensdata.Generic.Manipulator.Name), sprintf('Mirror%d.X',  mirror_idx))));\r","   par_mc.lens.(sprintf('Mi%d_y',  mirror_idx)) = adj_pob( find( strcmp( cellstr( lensdata.Generic.Manipulator.Name), sprintf('Mirror%d.Y',  mirror_idx))));\r","   par_mc.lens.(sprintf('Mi%d_z',  mirror_idx)) = adj_pob( find( strcmp( cellstr( lensdata.Generic.Manipulator.Name), sprintf('Mirror%d.Z',  mirror_idx))));\r","   par_mc.lens.(sprintf('Mi%d_Rx', mirror_idx)) = adj_pob( find( strcmp( cellstr( lensdata.Generic.Manipulator.Name), sprintf('Mirror%d.Rx', mirror_idx))));\r","   par_mc.lens.(sprintf('Mi%d_Ry', mirror_idx)) = adj_pob( find( strcmp( cellstr( lensdata.Generic.Manipulator.Name), sprintf('Mirror%d.Ry', mirror_idx))));\r","   par_mc.lens.(sprintf('Mi%d_Rz', mirror_idx)) = adj_pob( find( strcmp( cellstr( lensdata.Generic.Manipulator.Name), sprintf('Mirror%d.Rz', mirror_idx))));\r","end \r","par_mc.lens.Im_x                                = adj_pob( find( strcmp( cellstr( lensdata.Generic.Manipulator.Name), 'Wafer.X')));\r","par_mc.lens.Im_y                                = adj_pob( find( strcmp( cellstr( lensdata.Generic.Manipulator.Name), 'Wafer.Y')));\r","par_mc.lens.Im_z                                = adj_pob( find( strcmp( cellstr( lensdata.Generic.Manipulator.Name), 'Wafer.Z')));\r","par_mc.lens.Im_Rx                               = adj_pob( find( strcmp( cellstr( lensdata.Generic.Manipulator.Name), 'Wafer.Rx')));\r","par_mc.lens.Im_Ry                               = adj_pob( find( strcmp( cellstr( lensdata.Generic.Manipulator.Name), 'Wafer.Ry')));\r","par_mc.lens.Im_Rz                               = adj_pob( find( strcmp( cellstr( lensdata.Generic.Manipulator.Name), 'Wafer.Rz')));\r","\r","\r","%% CORs\r","COR.lens.Z2 =  spline( ml_dyn_input_dlm.wd.xf', ml_dyn_input_dlm.layer.wr.dx', lensdata.X)* lensdata.Generic.Lens.Factors.dZ2_dX ; %[m]\r","COR.lens.Z3 =  spline( ml_dyn_input_dlm.wd.xf', ml_dyn_input_dlm.layer.wr.dy', lensdata.X)* lensdata.Generic.Lens.Factors.dZ3_dY ; %[m]\r","for ichk = 1:2\r","    COR.hoc(ichk)=ml_input_HOC(ichk);\r","end\r","\r","%% KPIs\r","\r","% KPI4, RES1\r","lens_res = ovl_sub(extra_data.input.lens, extra_data.corr.lens);\r","KPI.maxLensRes.dx = max(abs(lens_res.layer.wr.dx));\r","KPI.maxLensRes.dy = max(abs(lens_res.layer.wr.dy));\r","RES.LensRes.dx = lens_res.layer.wr.dx; \r","RES.LensRes.dy = lens_res.layer.wr.dy; \r","\r","% KPI2\r","KPI.maxLensCorr.dx = max(abs(extra_data.corr.lens.layer.wr.dx));\r","KPI.maxLensCorr.dy = max(abs(extra_data.corr.lens.layer.wr.dy));\r","\r","% KPI6\r","tmp = ovl_average_columns( extra_data.input.lens);\r","z2 = tmp.layer.wr.dx * lensdata.Generic.Lens.Factors.dZ2_dX;\r","p = polyfit(lensdata.X * 100, z2' * 1e9, 3);  % m - > cm, m -> nm\r","z2_2 = p(2);  \r","%figure; plot(lensdata.X * 100, z2'*1e9,'.-')\r","\r","z3 = tmp.layer.wr.dy * lensdata.Generic.Lens.Factors.dZ3_dY;\r","p=polyfit(lensdata.X * 100, z3' * 1e9, 3);  % m - > cm\r","z3_2 = p(2);   % m -> nm\r","%figure; plot(lensdata.X * 100, z3'*1e9,'.-')\r","\r","KPI.Z2_2 = z2_2;\r","KPI.Z3_2 = z3_2;\r","\r","for ichk = 1:2\r","     % RES3\r","   hoc_res(ichk) = ovl_sub(extra_data.input.scan(ichk), extra_data.corr.scan(ichk));\r","   RES.HOCRes(ichk).dx = hoc_res(ichk).layer.wr.dx;\r","   RES.HOCRes(ichk).dy = hoc_res(ichk).layer.wr.dy;\r","\r","    % RES2\r","   total_res(ichk) = ovl_add(hoc_res(ichk), lens_res);\r","   RES.TotalRes(ichk).dx = total_res(ichk).layer.wr.dx; \r","   RES.TotalRes(ichk).dy = total_res(ichk).layer.wr.dy; \r","\r","   % KPI3\r","   KPI.maxTotalRes(ichk).dx = max(abs(total_res(ichk).layer.wr.dx));  \r","   KPI.maxTotalRes(ichk).dy = max(abs(total_res(ichk).layer.wr.dy));  \r","\r","   % KPI1\r","   if ichk == 1\r","       total_corr(ichk) = ovl_sub(ml_field_chk1, total_res(ichk));\r","   elseif ichk == 2\r","       total_corr(ichk) = ovl_sub(ml_field_chk2, total_res(ichk));\r","   end\r","   KPI.maxTotalCorr(ichk).dx = max(abs(total_corr(ichk).layer.wr.dx));   \r","   KPI.maxTotalCorr(ichk).dy = max(abs(total_corr(ichk).layer.wr.dy));\r","\r","   % KPI5 : temporary fix to make the CET model work\r","%     if ~isempty(options.CET_model)\r","%         KPI.FadingMSD(ichk).x = '';\r","%         KPI.FadingMSD(ichk).y = '';\r","%     else\r","%         [max_dx,max_dy,max_msdx,max_msdy,~,~] = JIMI_calc_profile_fading_v4(ml_input_HOC(ichk),intra_par_HOC(ichk));\r","%         KPI.FadingMSD(ichk).x = max_msdx;\r","%         KPI.FadingMSD(ichk).y = max_msdy;\r","%     end\r","    % tmp fix only commented all out and added next two lines.\r","    % Needs fixing with new HOCmodel and use of cet_model\r","    KPI.FadingMSD(ichk).x = '';\r","    KPI.FadingMSD(ichk).y = '';\r","\r","\r","    % KPI7\r","   KPI.maxHOCCorr(ichk).dx = max(abs(extra_data.corr.scan(ichk).layer.wr.dx));\r","   KPI.maxHOCCorr(ichk).dy = max(abs(extra_data.corr.scan(ichk).layer.wr.dy));\r","\r","   % KPI8\r","   KPI.maxHOCRes(ichk).dx = max(abs(hoc_res(ichk).layer.wr.dx));\r","   KPI.maxHOCRes(ichk).dy = max(abs(hoc_res(ichk).layer.wr.dy));\r","end\r",""],"CoverageData":{"CoveredLineNumbers":[],"UnhitLineNumbers":[18,19,20,21,22,23,24,27,28,29,30,31,32,33,38,39,40,44,45,53,54,55,56,60,63,64,65,66,68,69,70,71,72,73,74,75,76,77,78,79,84,85,89,90,91,93,97,98,101,102,103,110,112,116,117,119,120,122,123,125,126,130,131,132,133,137,138,139,140,141,142,143,145,146,147,151,152,153,154,155,156,157,158,159,160,161,163,164,165,166,167,168,172,173,174,175,181,182,183,184,185,188,189,192,193,194,195,198,199,200,203,204,206,208,209,210,213,214,215,218,219,222,223,224,225,227,228,241,242,246,247,250,251],"HitCount":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}}