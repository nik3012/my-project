var sourceData360 = {"FileContents":["classdef bmmo_LensModelDefault < bmmo_LensModel\r","    %% bmmo_LensModelDefault BMMO & BL3 NXE Lens model.\r","    %\r","    % This class calculates the KPIs, correction & residuals of the Lens\r","    % model. For details on the model see the EDS (D000347979)\r","    %\r","    % bmmo_LensModelDefault Properties:\r","    %   mlIn               - Chuck-averaged SBC ffp in ml format\r","    %   mlInScanIntegrated - Scan integrated mlIn, calculated automatically\r","    %   mlInDlm            - Input to DLM, calculated automatically\r","    %   mlOut              - Lens Model correction\r","    %   mlRes              - Lens Model residual\r","    %   report             - Lens model KPI report\r","    %   lensData           - lensData used by DLM\r","    %   lfp                - SDM Res saved to MC, load with readLfpFromMdl()\r","    %   timeFilterCoeff    - SBC Intrafield weight factor, only used with lfp\r","    %\r","    % bmmo_InlineSdmModelDefault Methods:\r","    %   calcActuation  - Calculate Lens correction\r","    %   run            - Calculate Len report & correction\r","    %   readLfpFromMdl - Read LFP from MDL file into lfp property\r","    %   distoToZernike - Convert an ml disto to z2, z3 distribution\r","    %   zernikeToDisto - Convert z2, z3 distribution into ml disto\r","    %\r","    % See also:\r","    %   bmmo_LensModel\r","    \r","    properties\r","        mlIn = ovl_average_fields(...\r","            ovl_create_dummy('13x19', 'nlayer', 1)); % Chuck-averaged SBC ffp in ml format\r","        mlWaferIn = bmmo_process_input(bmmo_default_input);\r","        mlWaferOut\r","        zernikes \r","        lfp double = zeros(1, 13, 64); % SDM Res saved to MC, load with readLfpFromMdl()\r","        timeFilterCoeff  = 1; % SBC Intrafield weight factor, only used with lfp\r","    end\r","    \r","    properties (SetAccess = private)\r","        mlOut struct % Lens Model correction\r","        report = struct('par', []) % Lens model KPI report\r","        lensData struct % lensData used by DLM\r","    end\r","    \r","    properties (Dependent, SetAccess = private)\r","        mlInScanIntegrated struct % Input to DLM, calculated automatically\r","        mlInDlm struct % Input to DLM, calculated automatically\r","        mlRes struct % Lens Model residual\r","        mlTemplate struct % Template created from mlWaferIn\r","    end\r","    \r","    methods\r","        function obj = bmmo_LensModelDefault(configuration, mlIn, mlWaferIn)\r","            % bmmo_LensModelDefault constructs object\r","            %\r","            % Usage\r","            %\r","            %   obj = bmmo_LensModelDefault(configuration)\r","            %       Constructs the object, mlIn can be set at a later time\r","            %\r","            %   obj = bmmo_LensModelDefault(configuration, mlIn)\r","            %       Constructs the object with the mlIn input. The\r","            %       corrections & report can be immediately generated from the object.\r","            %\r","            % Inputs\r","            %\r","            %   configuration   bmmo_Configuration object\r","            %   mlIn            ml structure with 1 wafer & 1 field\r","            %          Chuck averaged SBC ffp in ml format\r","            %          Default: all-zeros\r","            %\r","            % Outputs\r","            %\r","            %   obj    created object\r","            \r","            obj@bmmo_LensModel(configuration);\r","            obj.lensData = ovl_metro_get_lensdata('lenstype', obj.lensType);\r","            \r","            switch nargin\r","                case 3\r","                    obj.mlIn = mlIn;\r","                    obj.mlWaferIn = mlWaferIn;\r","                case 2\r","                    obj.mlIn = mlIn;\r","            end\r","            \r","            obj.mlOut = obj.mlIn;\r","            \r","\r","        end\r","        \r","        function run(obj)\r","            % bmmo_LensDefault method run\r","            %\r","            % Usage\r","            %\r","            %   obj.run()\r","            %       Run the Lens model and populate all the\r","            %       properties with model outputs\r","            obj.calcReport();\r","            obj.calcActuation();\r","        end\r","        \r","        function calcReport(obj)\r","            [z2_dlm_in, z3_dlm_in] = ...\r","                obj.distoToZernike(obj.mlInDlm, obj.lensData);\r","            \r","            [z2_out, z3_out] = obj.DLM_model_z2z3(z2_dlm_in, z3_dlm_in);\r","            \r","            obj.mlOut = obj.zernikeToDisto(...\r","                z2_out, z3_out, obj.lensData, obj.mlInScanIntegrated);\r","             \r","            obj.addPobFieldsToReport();\r","            obj.addLensCorrFieldsToReport();\r","        end\r","        \r","        function calcActuation(obj)\r","            % bmmo_LensModelDefault method calcCorrection\r","            %\r","            % Usage\r","            %\r","            %   obj.calcCorrection()\r","            %       Calculates correction (mlCorr) and residual (mlRes)\r","            [z2_dlm_in, z3_dlm_in] = ...\r","                obj.distoToZernike(obj.mlInDlm, obj.lensData);\r","            \r","            [z2_out, z3_out] = obj.DLM_model_z2z3(z2_dlm_in, z3_dlm_in);\r","            \r","            mlTemp = ovl_average_fields(obj.mlTemplate);\r","            \r","            mlLensAct = obj.zernikeToDisto(...\r","                z2_out, z3_out, obj.lensData, mlTemp);\r","          \r","            obj.mlWaferOut = ovl_distribute_field(mlLensAct, obj.mlWaferIn);\r","        end\r","        \r","        function readLfpFromMdl(obj, mdlPath)\r","            % bmmo_LensModelDefault method readLfpFromMdl\r","            %\r","            % Usage\r","            %\r","            %   obj.readLfpFromMdl(mdlPath)\r","            %       Loads the LFP from the MDL file, takes the slit average using the slit weights, and saves it into lfp\r","            \r","            loadedMdl = mdl_load(mdlPath, {'+KI-E001'}); %load MDL\r","            \r","            LfpZernikesFromMdlCell = loadedMdl.dat.LFP_data; % Extract LFP data from MDL\r","                       \r","            % Preallocating zernikeDecompositionLFP\r","            LfpZernikesFromMdl = zeros(length(LfpZernikesFromMdlCell.y), length(LfpZernikesFromMdlCell.y(1).zd), length(LfpZernikesFromMdlCell.y(1).zd{1,1}));\r","            \r","            % Loop over the height of the slit (different y values)\r","            for index = 1 : length(LfpZernikesFromMdlCell.y)\r","                % For each y value, create a matrix from the cell struct\r","                % stored in LFPzernikesFromMdl. Need to take transposes\r","                % twice to make dimensions match.\r","                LfpZernikesFromMdl(index, :, :) = cell2mat(LfpZernikesFromMdlCell.y(index).zd')';\r","            end\r","            \r","            % Take a weighted average over the slit (y-direction) using the\r","            % slit weights (5x13) stored in lensData, and shifting to make Z2 \r","            % and Z3 the second and third indices in the third dimension. \r","            % This collapses the 5x13x101 structure into a 1x13x100 structure.\r","            slitAveragedZernikesLfp = zeros([1, size(LfpZernikesFromMdl, 2, 3)]);\r","            for index = 2 : size(slitAveragedZernikesLfp, 3)\r","                slitAveragedZernikesLfp(1, :, index-1) = sum(LfpZernikesFromMdl(:, :, index).*obj.lensData.Generic.Lens.Slit_Weights, 1);\r","            end\r","            \r","            % Scale slit-averaged coefficients back from NM scale\r","            obj.lfp = slitAveragedZernikesLfp(:, :, (1 : size(obj.lfp, 3))) * 1e9;\r","        end\r","    end\r","    \r","    methods % Setters & Getters\r","        \r","        function set.mlWaferIn(obj, val)\r","            obj.mlWaferIn = val;\r","        end\r","        function val = get.mlInScanIntegrated(obj)\r","            val = ovl_scan_integrate(obj.mlIn);\r","        end\r","        \r","        function val = get.mlInDlm(obj)\r","            val = ovl_average_columns(obj.mlInScanIntegrated);\r","        end\r","        \r","        function val = get.mlRes(obj)\r","            val = ovl_sub(obj.mlInScanIntegrated, obj.mlOut);\r","        end\r","        function val = get.mlTemplate(obj)\r","            val = ovl_create_dummy(obj.mlWaferIn, 'nwafer', 1);\r","        end\r","        \r","    end\r","    \r","    methods (Access = private)\r","        function [z2_out, z3_out, dynamicCorrection, fadingCorrection] = ...\r","                DLM_model_z2z3(obj, z2_in, z3_in)\r","            \r","            % input and output(correctables) are in nm scale\r","            % (No unit conversion within the file)\r","            % Choose DLM\r","            driverLensModelResults = lm_calc_lens_model(obj.lensData.Generic, obj.lensData.DLM.LM(1));\r","            \r","            \r","            % Initialize structure containing Z2 and Z3 inputs\r","            sizeLfp = size(obj.lfp);\r","            zernikesFfp = zeros(sizeLfp); % field of 64 zernikes, all zeros (1x13x64)\r","            zernikesFfp(:,:,2) = z2_in;\r","            zernikesFfp(:,:,3) = z3_in;\r","\r","            % Extract Z2 and Z3 stored in LFP property\r","            slitAveragedZernikesLfp  = zeros(sizeLfp); % field of 64 zernikes, all zeros (1x13x64)\r","            slitAveragedZernikesLfp(:, :, (2 : 3)) = obj.lfp(:, :, (2 : 3)) * obj.timeFilterCoeff;\r","            \r","            % convert to Aber struct (5x13x64)\r","            aberrationsFfp = lm_calc_aberrations(zernikesFfp, 1:sizeLfp(3));\r","            aberrationsLfp  = lm_calc_aberrations(slitAveragedZernikesLfp, 1:sizeLfp(3));\r","            \r","            aberrationsDlmIn = aberrationsFfp;\r","            aberrationsDlmIn.Zernikes(:, :, 2:3)  = aberrationsFfp.Zernikes(:, :, 2:3)...\r","                + aberrationsLfp.Zernikes(:, :, 2:3);  %% Image tuner way\r","            beforeModel.Zernikes = aberrationsDlmIn.Zernikes;\r","            obj.report.par.m_before = max(max(abs(aberrationsDlmIn.Zernikes), [], 2), [], 1);\r","            \r","            % Calculate the adjustment corresponding to the aberration\r","            obj.report.adjPob = lm_calc_adjustments(driverLensModelResults, aberrationsDlmIn);    % adj in [um and urad]\r","            Corr = lm_calc_correction(obj.lensData.Generic, obj.report.adjPob); % Corr in [nm]\r","            obj.report.staticCorrZ = Corr;\r","            \r","            afterModel.Zernikes = beforeModel.Zernikes;\r","            for index = 1:size(Corr.Zernikes, 3)\r","                afterModel.Zernikes(:, :, index) = beforeModel.Zernikes(:, :, index) ...\r","                    + Corr.Zernikes(:, :, index);\r","            end\r","            \r","            obj.report.par.m_after = max(max(abs(afterModel.Zernikes), [], 2), [], 1);\r","            \r","            % Scan integrate lens Correctables of Zernikes\r","            % and separate Scan integrated part and fading\r","            \r","            % Dyn_corr = scan integrate(Corr),\r","            % Fad_corr = Corr(13x5 :copied in y) - Dyn_corr\r","            [dynamicCorrection, fadingCorrection] = lm_scan_integrate(obj.lensData.Generic, Corr);\r","            dynamicCorrectionZernikes = (-1) * lm_get_zernikes(dynamicCorrection, 1:sizeLfp(3));\r","            \r","            z2_out = dynamicCorrectionZernikes(3, :, 2);\r","            z3_out = dynamicCorrectionZernikes(3, :, 3);\r","        end\r","        \r","        \r","        function addPobFieldsToReport(obj)\r","            reportNames = {'Ob_z', 'Ob_Rx', 'Ob_Ry', 'Im_x', 'Im_y', ...\r","                'Im_z', 'Im_Rx', 'Im_Ry', 'Im_Rz'}; \r","            adjPobNames = {'Reticle.Z', 'Reticle.Rx', 'Reticle.Ry', ...\r","                'Wafer.X', 'Wafer.Y', 'Wafer.Z', 'Wafer.Rx', ...\r","                'Wafer.Ry', 'Wafer.Rz'};\r","            \r","            mirrorParamsRep = [\"x\", \"y\", \"z\", \"Rx\", \"Ry\", \"Rz\"];\r","            mirrorParamsPob = [\"X\", \"Y\", \"Z\", \"Rx\", \"Ry\", \"Rz\"];\r","            for iMirror = 1:6\r","                for jMiPar = 1:length(mirrorParamsRep)\r","                    reportNames{end + 1} = sprintf(\"Mi%d_\" + ...\r","                        mirrorParamsRep(jMiPar),  iMirror);\r","                    adjPobNames{end + 1} = sprintf(\"Mirror%d.\" + ...\r","                        mirrorParamsPob(jMiPar), iMirror);\r","                end\r","            end\r","            \r","            for iNames = 1:length(reportNames)\r","                obj.extractField(reportNames{iNames}, adjPobNames{iNames});\r","            end\r","        end\r","        \r","        function addLensCorrFieldsToReport(obj)\r","            mlInColAvg = ovl_average_columns(obj.mlIn);\r","            obj.report.Cor.lens.Z2 = spline(mlInColAvg.wd.xf', ...\r","                mlInColAvg.layer.wr.dx', obj.lensData.X) ...\r","                * obj.lensData.Generic.Lens.Factors.dZ2_dX ; %[m]\r","            obj.report.Cor.lens.Z3 = spline(mlInColAvg.wd.xf', ...\r","                mlInColAvg.layer.wr.dy', obj.lensData.X) ...\r","                * obj.lensData.Generic.Lens.Factors.dZ3_dY ; %[m]\r","            \r","            % KPI4, RES1\r","            lensRes = ovl_sub(obj.mlInScanIntegrated, obj.mlOut);\r","            obj.report.Kpi.maxLensRes.dx = max(abs(lensRes.layer.wr.dx));\r","            obj.report.Kpi.maxLensRes.dy = max(abs(lensRes.layer.wr.dy));\r","            obj.report.Res.Lens.dx = lensRes.layer.wr.dx;\r","            obj.report.Res.Lens.dy = lensRes.layer.wr.dy;\r","            \r","            % KPI2\r","            obj.report.Kpi.maxLensCorr.dx = max(abs(obj.mlOut.layer.wr.dx));\r","            obj.report.Kpi.maxLensCorr.dy = max(abs(obj.mlOut.layer.wr.dy));\r","            \r","            % KPI6\r","            z2 = mlInColAvg.layer.wr.dx ...\r","                * obj.lensData.Generic.Lens.Factors.dZ2_dX;\r","            p = polyfit(obj.lensData.X * 100, z2' * 1e9, 3);  % m - > cm, m -> nm\r","            z2_2 = p(2);\r","            \r","            z3 = mlInColAvg.layer.wr.dy ...\r","                * obj.lensData.Generic.Lens.Factors.dZ3_dY;\r","            p=polyfit(obj.lensData.X * 100, z3' * 1e9, 3);  % m - > cm\r","            z3_2 = p(2);   % m -> nm\r","            \r","            obj.report.Kpi.z2_2 = z2_2;\r","            obj.report.Kpi.z3_2 = z3_2;\r","        end\r","        \r","        function extractField(obj, reportName, adjPobName)\r","            obj.report.parMc.lens.(reportName)...\r","                = obj.report.adjPob(find(strcmp(cellstr(obj.lensData...\r","                .Generic.Manipulator.Name), adjPobName)));\r","        end\r","    end\r","    \r","    methods (Static = true)\r","        function [z2, z3] = distoToZernike(mlIn, lensData)\r","            % bmmo_LensDefault method distoToZernike\r","            % This method converts a field disto (mlIn) into a z2 & z3\r","            % Zernike distribution\r","            %\r","            % Usage\r","            %\r","            % [z2, z3] = distoToZernike(mlIn, lensData)\r","            %\r","            % Inputs\r","            %\r","            %   mlIn     ml structure \r","            %            Containing 1 wafer & 1 field\r","            %   lensData structure \r","            %            lensData structure, loaded from \r","            %            ovl_metro_get_lensdata\r","            %\r","            % Outputs\r","            %\r","            %   z2       structure\r","            %            Zernike z2 distribution\r","            %   z3       structure\r","            %            Zernike z3 distribution\r","            \r","            xs = spline(mlIn.wd.xf', mlIn.layer.wr.dx', lensData.X);\r","            ys = spline(mlIn.wd.xf', mlIn.layer.wr.dy', lensData.X);\r","            \r","            z2 = xs * lensData.Generic.Lens.Factors.dZ2_dX * 1e+09; %[nm]\r","            z3 = ys * lensData.Generic.Lens.Factors.dZ3_dY * 1e+09; %[nm]\r","        end\r","        \r","        function mlOut = zernikeToDisto(z2, z3, lensData, mlIn)\r","            % bmmo_LensDefault method distoToZernike\r","            % This method converts a z2 & z3 Zernike distribution into a\r","            % field disto based on the template (mlIn)\r","            %\r","            % Usage\r","            %\r","            % mlOut = zernikeToDisto(z2, z3, mlIn, lensData)\r","            %\r","            % Inputs\r","            %\r","            %   z2       structure\r","            %            Zernike z2 distribution\r","            %   z3       structure\r","            %            Zernike z3 distribution\r","            %   lensData structure \r","            %            lensData structure, loaded from \r","            %            ovl_metro_get_lensdata\r","            %   mlIn     ml structure \r","            %            Containing 1 wafer & 1 field, used as template\r","            %\r","            % Outputs\r","            %\r","            %   mlOut    ml structure \r","            %            With same structure as mlIn\r","            \r","            dx_corr_line = z2 / lensData.Generic.Lens.Factors.dZ2_dX * 10^(-9);\r","            dy_corr_line = z3 / lensData.Generic.Lens.Factors.dZ3_dY * 10^(-9);\r","            \r","            % calculate the effect of the LM correction in terms of\r","            % the avg disto field\r","            mlOut = mlIn;\r","            % use spline for the backward translation from\r","            % 13 points to the measured x positions\r","            mlOut.layer.wr.dx = spline(lensData.X, dx_corr_line, mlOut.wd.xf);\r","            mlOut.layer.wr.dy = spline(lensData.X, dy_corr_line, mlOut.wd.xf);\r","        end\r","    end\r","end\r","\r",""],"CoverageData":{"CoveredLineNumbers":[],"UnhitLineNumbers":[75,76,78,79,80,81,82,83,86,99,100,104,105,107,109,110,112,113,123,124,126,128,130,131,133,144,146,149,152,156,163,164,165,169,176,179,183,187,190,202,206,207,208,209,212,213,216,217,219,220,221,222,223,226,227,228,230,231,232,233,236,243,244,246,247,252,254,258,259,260,261,262,263,264,265,269,270,275,276,277,278,279,280,281,284,285,286,287,288,291,292,295,296,297,298,300,301,302,303,305,306,310,311,312,341,342,344,345,374,375,379,382,383],"HitCount":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}}