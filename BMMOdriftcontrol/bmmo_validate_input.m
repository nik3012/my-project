function bmmo_validate_input(input_struct)
% function bmmo_validate_input(input_struct)
%
% Throws an error if the input (data) structure is not as defined in the
% functional EDS
%
% Input:
% input_struct: Input structure as generated by bmmo_read_lcp_zip,
%               containing YieldStar measurements, report data from TwinScan and
%               and previous correction retrieved from TwinScan
%
% For definition of interface
% See D000323756 EDS

ml = input_struct;

% Define the expected fieldnames
fs = bmmo_expected_fields;

%% 1. Check root structure for fieldnames
found_ml_fieldnames = sub_get_sorted_fieldnames(ml);

% make sure that at least the fields in the EDS are present
sub_assert_subset(fs.expected_ml_fieldnames, found_ml_fieldnames,  'Fieldnames of ml struct are not as defined in EDS');

%% 2. Basic consistency check on layout
found_wd_fieldnames = sub_get_sorted_fieldnames(ml.wd);
sub_assert_equal(found_wd_fieldnames, fs.expected_wd_fieldnames, 'Fieldnames of ml.wd are not as defined in EDS');

nmarks  = length(ml.wd.xw);
sub_assert_equal(nmarks, ml.nmark * ml.nfield, 'Inconsistent definition of ml.nmark, ml.nfield');
sub_assert_equal(nmarks, length(ml.wd.xw), 'Inconsistent length for ml.wd.xw');
sub_assert_equal(nmarks, length(ml.wd.yw), 'Inconsistent length for ml.wd.yw');
sub_assert_equal(nmarks, length(ml.wd.xc), 'Inconsistent length for ml.wd.xc');
sub_assert_equal(nmarks, length(ml.wd.yc), 'Inconsistent length for ml.wd.yc');
sub_assert_equal(nmarks, length(ml.wd.xf), 'Inconsistent length for ml.wd.xf');
sub_assert_equal(nmarks, length(ml.wd.yf), 'Inconsistent length for ml.wd.yf');

% Check that there are no duplicate mark coordinates
x_y = ml.wd.xw + 1i * ml.wd.yw;
sub_assert_equal(length(unique(x_y)), nmarks, 'Duplicate mark coordinates found in input');

%% 3. Basic consistency check on wafer maps
sub_assert_equal(ml.nlayer, 1, 'Input ml struct must have exactly one layer');
sub_assert_equal(length(ml.layer), ml.nlayer, 'Inconsistent definition of ml.layer');

found_fieldnames = sub_get_sorted_fieldnames(ml.layer);
sub_assert_equal(found_fieldnames, fs.expected_layer_fieldnames, 'Fieldnames of ml.layer are not as defined in EDS');

sub_assert_equal(length(ml.layer.wr), ml.nwafer, 'Inconsistent definition of ml.layer.wr');

for iw = 1:ml.nwafer
    sub_assert_equal(length(ml.layer.wr(iw).dx), nmarks, 'Inconsistent definition of ml.layer.wr.dx');
    sub_assert_equal(length(ml.layer.wr(iw).dy), nmarks, 'Inconsistent definition of ml.layer.wr.dy');
end

%% 4. Check info fieldnames
found_fieldnames = sub_get_sorted_fieldnames(ml.info);
sub_assert_subset(fs.expected_info_fieldnames, found_fieldnames, 'Fieldnames of ml.info are not as defined in EDS');

%% 4.1 Check report data
found_fieldnames = sub_get_sorted_fieldnames(ml.info.report_data);

sub_assert_subset(fs.expected_report_data_fieldnames, found_fieldnames, 'Fieldnames of ml.info.report_data are not as defined in EDS');

%sub_assert( length(ml.info.report_data.Scan_direction) >= ml.nfield, 'Not enough scan directions defined for the number of fields');

sub_assert_equal(length(ml.info.report_data.WH_K_factors.wafer), ml.nwafer, 'Not enough WH K-factors per wafer');

% check the first field for K-factors. 
% K-factors names must be in the correct order.
K_factor_names = reshape(fieldnames(ml.info.report_data.WH_K_factors(1).wafer(1).field), 1, []);

sub_assert_equal(lower(K_factor_names), lower(fs.expected_parlist), 'WH K-factors not present as defined in EDS');

%% 4.2 Check previous correction
found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction);
sub_assert_subset(found_fieldnames, fs.expected_pc_fieldnames, 'Previous_correction not as defined in EDS');

found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.KA);

if isfield(ml.info.previous_correction.KA, 'grid_2dc')% For backwards compatiblity
    sub_assert_subset(fs.expected_KA_fieldnames, found_fieldnames, 'pc.KA fieldnames not as defined in EDS');
    %KA@E
    found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.KA.grid_2de(1));
    sub_assert_equal(found_fieldnames, fs.expected_ffp_fieldnames, 'pc.KA.grid_2de fieldnames not as defined in EDS');
    %KA@M
    found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.KA.grid_2dc(1));
    sub_assert_equal(found_fieldnames, fs.expected_ffp_fieldnames, 'pc.KA.grid_2dc fieldnames not as defined in EDS');
else
    %KA@E
    sub_assert_subset(fs.expected_KA_E_fieldnames, found_fieldnames, 'pc.KA fieldnames not as defined in EDS');
    
    found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.KA.grid_2de(1));
    sub_assert_equal(found_fieldnames, fs.expected_ffp_fieldnames, 'pc.KA.grid_2de fieldnames not as defined in EDS');
end


found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.MI);
sub_assert_equal(found_fieldnames, fs.expected_MI_fieldnames, 'pc.MI fieldnames not as defined in EDS');

found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.MI.wse(1));
sub_assert_equal(found_fieldnames, fs.expected_MI_wse_fieldnames, 'pc.MI.wse fieldnames not as defined in EDS');

found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.MI.wse(1).x_mirr);
sub_assert_equal(found_fieldnames, fs.expected_MI_x_mirr_fieldnames, 'pc.MI.wse.x_mirr fieldnames not as defined in EDS');

found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.MI.wse(1).y_mirr);
sub_assert_equal(found_fieldnames, fs.expected_MI_y_mirr_fieldnames, 'pc.MI.wse.y_mirr fieldnames not as defined in EDS');

found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.ffp);
sub_assert_equal(found_fieldnames, fs.expected_ffp_fieldnames, 'pc.ffp fieldnames not as defined in EDS');

found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.BAO);
sub_assert_equal(found_fieldnames, fs.expected_BAO_fieldnames, 'pc.BAO fieldnames not as defined in EDS');

if isfield(ml.info.previous_correction, 'SUSD')
    found_fieldnames = sub_get_sorted_fieldnames(ml.info.previous_correction.SUSD);
    sub_assert_equal(fs.expected_SUSD_fieldnames, found_fieldnames, 'pc.SUSD fieldnames not as defined in EDS');
end

%% 4.3 Check info.F structure
found_fieldnames = sub_get_sorted_fieldnames(ml.info.F);
if isfield(ml.info.F, 'image_shift')
    sub_assert_equal(found_fieldnames, fs.expected_F_image_shift_fieldnames,'info.F fieldnames not as defined in EDS');
else
    sub_assert_equal(found_fieldnames, fs.expected_F_fieldnames, 'info.F fieldnames not as defined in EDS');
end
sub_assert_equal(length(ml.info.F.chuck_id), ml.nwafer, 'Inconsistent definition of info.F.chuck_id');
sub_assert_equal(length(ml.info.F.wafer_accepted), ml.nwafer, 'Inconsistent definition of info.F.wafer_accepted');

%% 4.4 Check info.M structure
found_fieldnames = sub_get_sorted_fieldnames(ml.info.M);
sub_assert_equal(found_fieldnames, fs.expected_M_fieldnames, 'info.M fieldnames not as defined in EDS');


%% 5. Check expinfo structure
found_fieldnames = sub_get_sorted_fieldnames(ml.expinfo);
sub_assert_subset(fs.expected_expinfo_fieldnames, found_fieldnames, 'info.expinfo not as defined in EDS');


%% End of main function, sub-functions below

    %% Fail if a is not a subset of b, uses R13-compatible version of assert
    function sub_assert_subset(a, b, msg)
        
    common = intersect(a, b);
    sub_assert_equal(common, a, msg);

    %% R13-compatible version of assert_equal
    function sub_assert_equal(a, b, msg)

    result = isequal(a,b);
    sub_assert(result, msg);

    %% R13-compatible version of assert
    function sub_assert(result, msg)

    if ~result
        error_r12(['invalid_input ', msg]);
    end

    %% Return the fieldnames of input_struct, sorted into one row
    function fnames = sub_get_sorted_fieldnames(input_struct)

    fnames = sort(reshape(fieldnames(input_struct), 1, []));

